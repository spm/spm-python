<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>spm.spm_field API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spm.spm_field</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spm.spm_field.spm_field"><code class="name flex">
<span>def <span class="ident">spm_field</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spm_field(*args, **kwargs):
    &#34;&#34;&#34;
      A compiled routine for various spatially regularised inverse problems  
       __________________________________________________________________________  
         
        FORMAT v = spm_field(H, g, param)  
        v     - the solution (n1*n2*n3*n4, single)  
        H     - parameterisation of a Hessian at each voxel  
                (n1*n2*n3*(n4*(n4-1)), single)  
                Because the Hessian is symmetric, elements along the  
                4th dimension are ordered:  
                h(1,1), h(2,2), h(3,3),... h(1,2), h(1,3), ..., h(2,3)...  
                Each vector along the 4th dimension should encode a  
                positive (semi)definite matrix.  
        g     - parameterisation of first derivatives (n1*n2*n3*n4, single)  
        param - 10 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6] Regularisation settings.  
                  - [4] Penalty on absolute values.  
                  - [5] Penalty on the `membrane energy&#39;. This penalises  
                        the sum of squares of the gradients of the values.  
                  - [6] Penalty on the `bending energy&#39;. This penalises  
                        the sum of squares of the 2nd derivatives.  
                - [7]       Number of Full Multigrid cycles.  
                - [8]       Number of relaxation iterations per cycle.  
         
        The function solves equations using a Full Multigrid method (see  
        Press et al for more information), but incorporating the Hessian  
        of some form of likelihood term.  
        v = inv(A+B)*g  
            where A = param(4)*I + param(5)*L + param(6)*L&#39;*L  
            and   I = kron(kron(Iz,Iy),Ix)  
                  L = kron(kron(Lz,Iy),Ix) + kron(kron(Iz,Ly),Ix) + kron(kron(Iz,Iy),Lx)  
         
                  Ix = eye(n1); Iy = eye(n2); Iz = eye(n3)  
                  Lx = toeplitz([2 -1 0 ... 0 -1]/param(1)^2) etc  
         
        Note that for ill-conditioned A, some regularisation of the solution  
        is included.  This means that the solution is not identical to that  
        computed using other methods, it is still appropriate for use in  
        Gauss-Newton type optimisation schemes.  
       __________________________________________________________________________  
         
        FORMAT u = spm_field(&#39;vel2mom&#39;, v, param)  
        v     - A field (n1*n2*n3*n4, single).  
        param - 6 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6] Regularisation parameters  
        u       - Result of applying differential operator (n1*n2*n3*n4, single).  
         
        This generates u = A*v, where A is computed as described above.  
       __________________________________________________________________________  
         
        FORMAT b = spm_field(&#39;boundary&#39;)  
        Get the current boundary condition.  
        b - boundary condition  
            0 - field wraps around at the boundary, as if the field is on a  
                torus (circulant).  This is typically assumed when using  
                FFTs for convolution etc.  
            1 - Neumann boundary condition.  
            Note that after a `clear functions&#39; in MATLAB, the boundary  
            condition is reset to 0.  
       __________________________________________________________________________  
         
        FORMAT spm_field(&#39;boundary&#39;,b)  
        Set the boundary condition.  
        b - boundary condition (0 or 1, see above).   
       ==========================================================================  
       ==========================================================================  
         
        L1: The following functions are dedicated to L1 types of penalties  
            (total-variation, etc.), when solved using a reweighted least   
            squares algorithm.  
            Currently, only membrane energy is implemented.  
       __________________________________________________________________________  
         
        FORMAT u = spm_field(&#39;vel2mom1&#39;, v, w, param)  
        v     - A field (n1*n2*n3*n4, single).  
        w     - A field (n1*n2*n3, single) of positive weights.  
        param - 4 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4]       Regularisation parameter (membrane energy)  
        u       - Result of applying differential operator (n1*n2*n3*n4, single).  
         
        This is a generalisation of vel2mom for differential operators that are  
        locally weighted. w contains a map of positive weights that are shared  
        across channels.  
       __________________________________________________________________________  
         
        FORMAT u = spm_field(&#39;diaginv1&#39;, H, w, param)  
        H     - Parameterisation of a Hessian at each voxel  
                (n1*n2*n3*(n4*(n4-1)), single)  
        w     - A field (n1*n2*n3, single) of positive weights.  
        param - 4 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4]       Regularisation parameter (membrane energy)  
        u       - diag(inv(H + L)).  
         
        This function computes the diagonal of the inverse of the Hessian  
        (u = diag(inv(H + L))). To make the inversion tractable, L is   
        approximated by its diagonal. It allows to approximate the posterior  
        uncertainty  in a (Bayesian) reweighted least-squares setting.   
       __________________________________________________________________________  
         
        FORMAT u = spm_field(&#39;trinv1&#39;, H, w, param)  
        H     - Parameterisation of a Hessian at each voxel  
                (n1*n2*n3*(n4*(n4-1)), single)  
        w     - A field (n1*n2*n3, single) of positive weights.  
        param - 4 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4]       Regularisation parameter (membrane energy)  
        u       - trace(inv(H + L)).  
         
        This function computes the trace of the inverse of the Hessian  
        (u = trace(inv(H + L))). To make the inversion tractable, L is   
        approximated by its diagonal. It allows to approximate the posterior  
        uncertainty  in a (Bayesian) reweighted least-squares setting.   
       __________________________________________________________________________  
         
        FORMAT Ap = spm_field(&#39;Atimesp&#39;, A, p)  
        A     - A field of symmetric matrices (n1*n2*n3*(n4*(n4-1)), single)  
        p     - A field (n1*n2*n3*n4, single).  
        Ap    - A*p.  
         
        This function computes efficiently a lot of matrix-vector products.  
       __________________________________________________________________________  
      

    [Matlab code]( https://github.com/spm/spm/blob/main/spm_field.m )

    Copyright (C) 1995-2025 Functional Imaging Laboratory, Department of Imaging Neuroscience, UCL
    &#34;&#34;&#34;
    return Runtime.call(&#34;spm_field&#34;, *args, **kwargs)</code></pre>
</details>
<div class="desc"><p>A compiled routine for various spatially regularised inverse problems
</p>
<hr>
<pre><code>FORMAT v = spm_field(H, g, param)  
v     - the solution (n1*n2*n3*n4, single)  
H     - parameterisation of a Hessian at each voxel  
        (n1*n2*n3*(n4*(n4-1)), single)  
        Because the Hessian is symmetric, elements along the  
        4th dimension are ordered:  
        h(1,1), h(2,2), h(3,3),... h(1,2), h(1,3), ..., h(2,3)...  
        Each vector along the 4th dimension should encode a  
        positive (semi)definite matrix.  
g     - parameterisation of first derivatives (n1*n2*n3*n4, single)  
param - 10 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6] Regularisation settings.  
          - [4] Penalty on absolute values.  
          - [5] Penalty on the `membrane energy'. This penalises  
                the sum of squares of the gradients of the values.  
          - [6] Penalty on the `bending energy'. This penalises  
                the sum of squares of the 2nd derivatives.  
        - [7]       Number of Full Multigrid cycles.  
        - [8]       Number of relaxation iterations per cycle.

The function solves equations using a Full Multigrid method (see  
Press et al for more information), but incorporating the Hessian  
of some form of likelihood term.  
v = inv(A+B)*g  
    where A = param(4)*I + param(5)*L + param(6)*L'*L  
    and   I = kron(kron(Iz,Iy),Ix)  
          L = kron(kron(Lz,Iy),Ix) + kron(kron(Iz,Ly),Ix) + kron(kron(Iz,Iy),Lx)

          Ix = eye(n1); Iy = eye(n2); Iz = eye(n3)  
          Lx = toeplitz([2 -1 0 ... 0 -1]/param(1)^2) etc

Note that for ill-conditioned A, some regularisation of the solution  
is included.  This means that the solution is not identical to that  
computed using other methods, it is still appropriate for use in  
Gauss-Newton type optimisation schemes.
</code></pre>
<hr>
<pre><code>FORMAT u = spm_field('vel2mom', v, param)  
v     - A field (n1*n2*n3*n4, single).  
param - 6 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6] Regularisation parameters  
u       - Result of applying differential operator (n1*n2*n3*n4, single).

This generates u = A*v, where A is computed as described above.
</code></pre>
<hr>
<pre><code>FORMAT b = spm_field('boundary')  
Get the current boundary condition.  
b - boundary condition  
    0 - field wraps around at the boundary, as if the field is on a  
        torus (circulant).  This is typically assumed when using  
        FFTs for convolution etc.  
    1 - Neumann boundary condition.  
    Note that after a `clear functions' in MATLAB, the boundary  
    condition is reset to 0.
</code></pre>
<hr>
<pre><code>FORMAT spm_field('boundary',b)  
Set the boundary condition.  
b - boundary condition (0 or 1, see above).
</code></pre>
<p>==========================================================================<br>
==========================================================================
</p>
<pre><code>L1: The following functions are dedicated to L1 types of penalties  
    (total-variation, etc.), when solved using a reweighted least   
    squares algorithm.  
    Currently, only membrane energy is implemented.
</code></pre>
<hr>
<pre><code>FORMAT u = spm_field('vel2mom1', v, w, param)  
v     - A field (n1*n2*n3*n4, single).  
w     - A field (n1*n2*n3, single) of positive weights.  
param - 4 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4]       Regularisation parameter (membrane energy)  
u       - Result of applying differential operator (n1*n2*n3*n4, single).

This is a generalisation of vel2mom for differential operators that are  
locally weighted. w contains a map of positive weights that are shared  
across channels.
</code></pre>
<hr>
<pre><code>FORMAT u = spm_field('diaginv1', H, w, param)  
H     - Parameterisation of a Hessian at each voxel  
        (n1*n2*n3*(n4*(n4-1)), single)  
w     - A field (n1*n2*n3, single) of positive weights.  
param - 4 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4]       Regularisation parameter (membrane energy)  
u       - diag(inv(H + L)).

This function computes the diagonal of the inverse of the Hessian  
(u = diag(inv(H + L))). To make the inversion tractable, L is   
approximated by its diagonal. It allows to approximate the posterior  
uncertainty  in a (Bayesian) reweighted least-squares setting.
</code></pre>
<hr>
<pre><code>FORMAT u = spm_field('trinv1', H, w, param)  
H     - Parameterisation of a Hessian at each voxel  
        (n1*n2*n3*(n4*(n4-1)), single)  
w     - A field (n1*n2*n3, single) of positive weights.  
param - 4 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4]       Regularisation parameter (membrane energy)  
u       - trace(inv(H + L)).

This function computes the trace of the inverse of the Hessian  
(u = trace(inv(H + L))). To make the inversion tractable, L is   
approximated by its diagonal. It allows to approximate the posterior  
uncertainty  in a (Bayesian) reweighted least-squares setting.
</code></pre>
<hr>
<pre><code>FORMAT Ap = spm_field('Atimesp', A, p)  
A     - A field of symmetric matrices (n1*n2*n3*(n4*(n4-1)), single)  
p     - A field (n1*n2*n3*n4, single).  
Ap    - A*p.

This function computes efficiently a lot of matrix-vector products.
</code></pre>
<hr>
<p><a href="https://github.com/spm/spm/blob/main/spm_field.m">Matlab code</a></p>
<p>Copyright (C) 1995-2025 Functional Imaging Laboratory, Department of Imaging Neuroscience, UCL</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spm" href="index.html">spm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spm.spm_field.spm_field" href="#spm.spm_field.spm_field">spm_field</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
