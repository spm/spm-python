<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>__wrapper__ API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>__wrapper__</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="__wrapper__.AnyDelayedArray"><code class="flex name class">
<span>class <span class="ident">AnyDelayedArray</span></span>
<span>(</span><span>parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyDelayedArray(AnyMatlabArray):
    &#34;&#34;&#34;
    This is an object that we return when we don&#39;t know how an indexed
    element will be used yet.

    It decides whether it is a Struct, Cell or Array based on the
    type of indexing that is used.

    In Matlab:
        * `a(x,y)   = num`  indicates that `a` is a numeric array;
        * `a(x,y)   = cell` indicates that `a` is a cell array;
        * `a{x,y}   = any`  indicates that `a` is a cell array;
        * `a(x,y).f = any`  indicates that `a` is a struct array;
        * `a.f      = any`  indicates that `a` is a struct.

    These indexing operations can be chained, so in
    `a(x).b.c{y}.d(z) = 2`:
        * `a`    is a struct array;
        * `b`    is a struct;
        * `c`    is a cell;
        * `c{y}` is a struct
        * `d`    is a numeric array.

    In Python, there is only one type of indexing (`[]`). This is a problem as
    we cannot differentiate `a{x}.b = y` -- where `a` is a cell that contains
    a struct -- from `a(x).b = y` --- where `a` is a struct array.

    One solution may be to abuse the &#34;call&#34; operator `()`, so that it returns a
    cell. This would work in some situations (`a[x].b = y` is a struct array,
    whereas `a(x).b = y` is a cell of struct). However, the statement
    `a(x) = y` (which would correspond to matlab&#39;s `a{x} = y`) is not valid
    python syntax. Furthermore, it would induce a new problem, as cells could
    not be differentiated from function handles, in some cases.

    Instead, the use of brackets automatically transforms the object into
    either:
    * a `Struct` (in all &#34;get&#34; cases, and in the &#34;set&#34; context `a[x] = y`,
      when `y` is either a `dict` or a `Struct`); or
    * a `Array` (in the &#34;set&#34; context `a[x] = y`, when `y` is neither a
      `dict` nor a `Struct`).

    Alternatively, if the user wishes to specify which type the object should
    take, we implement the properties `as_cell`, `as_struct` and `as_num`.

    Therefore:
    * `a[x,y]             = num`    : `a` is a numeric array;
    * `a[x,y]             = struct` : `a` is a numeric array;
    * `a[x,y].f           = any`    : `a` is a struct array;
    * `a(x,y).f           = any`    : `a` is a cell array containing a struct;
    * `a.f                = any`    : `a` is a struct.

    And explictly:
    * `a.as_cell[x,y]     = any`    : `a` is a cell array;
    * `a.as_struct[x,y].f = any`    : `a` is a struct array;
    * `a.as_cell[x,y].f   = any`    : `a` is a cell array containing a struct;
    * `a.as_num[x,y]      = num`    : `a` is a numeric array.
    &#34;&#34;&#34;

    _ATTRIBUTES = (&#34;_parent&#34;, &#34;_index&#34;, &#34;_future&#34;, &#34;_finalized&#34;)

    def __init__(self, parent, *index):
        &#34;&#34;&#34;
        Parameters
        ----------
        parent : ndarray | dict
            Reference to the object that will eventually contain
            this element.
            * If the containing array is a Cell, `parent` should be a
              `ndarray` view of that cell, and `index` should be a
              [tuple of] int.
            * If the containing array is a Struct, `parent` should be a
              `dict`, and `index` should be a string.
        index : str | [tuple of] int
            Index into the parent where this element will be inserted.
        &#34;&#34;&#34;
        super().__init__()
        self._parent = parent       # reference to parent container
        self._index = index         # index into parent container
        self._future = None         # future array
        self._finalized = False     # whether this array has been finalized

    @property
    def _final(self):
        self._finalize()
        return self._future

    def _finalize(self):
        if self._finalized:
            return

        if self._future is None:
            # FIXME: I am not entirely sure this should ever happen
            self._future = _empty_array()

        # if future array is wrapped, unwrap it
        if isinstance(self._future, WrappedDelayedArray):
            self._future = self._future._future
            if hasattr(self._future, &#34;_delayed_wrapper&#34;):
                del self._future._delayed_wrapper

        # set value in parent
        parent = self._parent
        for index in self._index[:-1]:
            parent = parent[index]
        parent[self._index[-1]] = self._future

        # finalize parent if needed
        if hasattr(self._parent, &#34;_final&#34;):
            self._parent = self._parent._final

        self._finalized = True

    def _error_is_not_finalized(self, *args, **kwargs):
        raise IndexOrKeyOrAttributeError(
            &#34;This DelayedArray has not been finalized, and you are &#34;
            &#34;attempting to use it in a way that may break its finalization &#34;
            &#34;cycle. It most likely means that you are indexing out-of-bounds &#34;
            &#34;without *setting* the out-of-bound value. &#34;
            &#34;Correct usage: `a.b(i).c = x` | Incorrect usage: `x = a.b(i).c`.&#34;
        )

    # Kill all operators
    __str__ = __repr__ = _error_is_not_finalized
    __bool__ = __float__ = __int__ = _error_is_not_finalized
    __ceil__ = __floor__ = __round__ = __trunc__ = _error_is_not_finalized
    __add__ = __iadd__ = __radd__ = _error_is_not_finalized
    __sub__ = __isub__ = __rsub__ = _error_is_not_finalized
    __mul__ = __imul__ = __rmul__ = _error_is_not_finalized
    __truediv___ = __itruediv___ = __rtruediv___ = _error_is_not_finalized
    __floordiv___ = __ifloordiv___ = __rfloordiv___ = _error_is_not_finalized
    __eq__ = __ne__ = _error_is_not_finalized
    __gt__ = __ge__ = __lt__ = __le__ = _error_is_not_finalized
    __abs__ = __neg__ = __pos__ = _error_is_not_finalized
    __pow__ = __ipow__ = __rpow__ = _error_is_not_finalized
    __mod__ = __imod__ = __rmod__ = _error_is_not_finalized
    __divmod__ = __idivmod__ = __rdivmod__ = _error_is_not_finalized
    __contains__ = _error_is_not_finalized

    def __getattribute__(self, name):
        # Do not allow any attribute to be accessed except for those
        # explicitly allowed by the AnyDelayedArray class.
        # This is so no &#34;computation&#34; is peformed on DelayedCell,
        # DelayedStruct, etc.
        if name.startswith(&#34;_&#34;):
            return super().__getattribute__(name)
        if name not in self.__dict__ and name not in AnyDelayedArray.__dict__:
            return self._error_is_not_finalized()
        return super().__getattribute__(name)

    # --- Promise type -------------------------------------------------

    @property
    def as_cell(self) -&gt; &#34;DelayedCell&#34;:
        if self._future is None:
            self._future = DelayedCell((), self._parent, *self._index)
        if not isinstance(self._future, DelayedCell):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a {Cell}&#34;
            )
        return self._future

    @property
    def as_struct(self) -&gt; &#34;DelayedStruct&#34;:
        if self._future is None:
            self._future = DelayedStruct((), self._parent, *self._index)
        if not isinstance(self._future, DelayedStruct):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a {Struct}&#34;
            )
        return self._future

    @property
    def as_num(self) -&gt; &#34;DelayedArray&#34;:
        if self._future is None:
            self._future = DelayedArray([0], self._parent, *self._index)
        if not isinstance(self._future, DelayedArray):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a {Array}&#34;
            )
        return self._future

    def as_obj(self, obj):
        if (
            self._future is not None and
            not isinstance(self._future, MatlabClass)
        ):
            raise TypeError(
                f&#34;{type(self._future)} cannot be interpreted as a {type(obj)}&#34;
            )
        self._future = obj
        return self._future

    # --- Guess promised type ------------------------------------------

    def __call__(self, *index):
        return self.as_cell(*index)

    def __getitem__(self, index):
        return self.as_struct[index]

    def __getattr__(self, key):
        return self.as_struct[key]

    def __setitem__(self, index, value):
        if isinstance(index, str):
            arr = self.as_struct

        elif isinstance(value, MatlabClass):
            if index not in (0, -1):
                raise NotImplementedError(
                    &#34;Implicit advanced indexing not implemented for&#34;,
                    type(value)
                )
            self.as_obj(value)
            return self._finalize()

        elif isinstance(value, (dict, Struct)):
            arr = self.as_struct
        elif isinstance(value, (tuple, list, set, Cell)):
            arr = self.as_cell
        elif isinstance(value, (int, float, np.number, Array)):
            arr = self.as_num
        elif isinstance(value, np.ndarray):
            if issubclass(value.dtype.type, np.number):
                arr = self.as_num
            else:
                arr = self.as_cell
        else:
            arr = self.as_cell

        arr[index] = value
        return self._finalize()  # Setter -&gt; we can trigger finalize

    def __setattr__(self, key, value):
        if key in type(self)._ATTRIBUTES:
            return super().__setattr__(key, value)
        self.as_struct[key] = value
        return self._finalize()  # Setter -&gt; we can trigger finalize</code></pre>
</details>
<div class="desc"><p>This is an object that we return when we don't know how an indexed
element will be used yet.</p>
<p>It decides whether it is a Struct, Cell or Array based on the
type of indexing that is used.</p>
<p>In Matlab:
* <code>a(x,y)
= num</code>
indicates that <code>a</code> is a numeric array;
* <code>a(x,y)
= cell</code> indicates that <code>a</code> is a cell array;
* <code>a{x,y}
= any</code>
indicates that <code>a</code> is a cell array;
* <code>a(x,y).f = any</code>
indicates that <code>a</code> is a struct array;
* <code>a.f
= any</code>
indicates that <code>a</code> is a struct.</p>
<p>These indexing operations can be chained, so in
<code>a(x).b.c{y}.d(z) = 2</code>:
* <code>a</code>
is a struct array;
* <code>b</code>
is a struct;
* <code>c</code>
is a cell;
* <code>c{y}</code> is a struct
* <code>d</code>
is a numeric array.</p>
<p>In Python, there is only one type of indexing (<code>[]</code>). This is a problem as
we cannot differentiate <code>a{x}.b = y</code> &ndash; where <code>a</code> is a cell that contains
a struct &ndash; from <code>a(x).b = y</code> &mdash; where <code>a</code> is a struct array.</p>
<p>One solution may be to abuse the "call" operator <code>()</code>, so that it returns a
cell. This would work in some situations (<code>a[x].b = y</code> is a struct array,
whereas <code>a(x).b = y</code> is a cell of struct). However, the statement
<code>a(x) = y</code> (which would correspond to matlab's <code>a{x} = y</code>) is not valid
python syntax. Furthermore, it would induce a new problem, as cells could
not be differentiated from function handles, in some cases.</p>
<p>Instead, the use of brackets automatically transforms the object into
either:
* a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code> (in all "get" cases, and in the "set" context <code>a[x] = y</code>,
when <code>y</code> is either a <code>dict</code> or a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>); or
* a <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code> (in the "set" context <code>a[x] = y</code>, when <code>y</code> is neither a
<code>dict</code> nor a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>).</p>
<p>Alternatively, if the user wishes to specify which type the object should
take, we implement the properties <code>as_cell</code>, <code>as_struct</code> and <code>as_num</code>.</p>
<p>Therefore:
* <code>a[x,y]
= num</code>
: <code>a</code> is a numeric array;
* <code>a[x,y]
= struct</code> : <code>a</code> is a numeric array;
* <code>a[x,y].f
= any</code>
: <code>a</code> is a struct array;
* <code>a(x,y).f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.f
= any</code>
: <code>a</code> is a struct.</p>
<p>And explictly:
* <code>a.as_cell[x,y]
= any</code>
: <code>a</code> is a cell array;
* <code>a.as_struct[x,y].f = any</code>
: <code>a</code> is a struct array;
* <code>a.as_cell[x,y].f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.as_num[x,y]
= num</code>
: <code>a</code> is a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>ndarray | dict</code></dt>
<dd>Reference to the object that will eventually contain
this element.
* If the containing array is a Cell, <code>parent</code> should be a
<code>ndarray</code> view of that cell, and <code>index</code> should be a
[tuple of] int.
* If the containing array is a Struct, <code>parent</code> should be a
<code>dict</code>, and <code>index</code> should be a string.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str | [tuple of] int</code></dt>
<dd>Index into the parent where this element will be inserted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="__wrapper__.AnyDelayedArray.as_cell"><code class="name">prop <span class="ident">as_cell</span> : <a title="__wrapper__.DelayedCell" href="#__wrapper__.DelayedCell">DelayedCell</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_cell(self) -&gt; &#34;DelayedCell&#34;:
    if self._future is None:
        self._future = DelayedCell((), self._parent, *self._index)
    if not isinstance(self._future, DelayedCell):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a {Cell}&#34;
        )
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="__wrapper__.AnyDelayedArray.as_num"><code class="name">prop <span class="ident">as_num</span> : <a title="__wrapper__.DelayedArray" href="#__wrapper__.DelayedArray">DelayedArray</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_num(self) -&gt; &#34;DelayedArray&#34;:
    if self._future is None:
        self._future = DelayedArray([0], self._parent, *self._index)
    if not isinstance(self._future, DelayedArray):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a {Array}&#34;
        )
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="__wrapper__.AnyDelayedArray.as_struct"><code class="name">prop <span class="ident">as_struct</span> : <a title="__wrapper__.DelayedStruct" href="#__wrapper__.DelayedStruct">DelayedStruct</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_struct(self) -&gt; &#34;DelayedStruct&#34;:
    if self._future is None:
        self._future = DelayedStruct((), self._parent, *self._index)
    if not isinstance(self._future, DelayedStruct):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a {Struct}&#34;
        )
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="__wrapper__.AnyDelayedArray.as_obj"><code class="name flex">
<span>def <span class="ident">as_obj</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_obj(self, obj):
    if (
        self._future is not None and
        not isinstance(self._future, MatlabClass)
    ):
        raise TypeError(
            f&#34;{type(self._future)} cannot be interpreted as a {type(obj)}&#34;
        )
    self._future = obj
    return self._future</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.AnyMatlabArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.AnyMatlabArray"><code class="flex name class">
<span>class <span class="ident">AnyMatlabArray</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyMatlabArray(MatlabType):
    &#34;&#34;&#34;Base class for all matlab-like arrays (numeric, cell, struct).&#34;&#34;&#34;

    @property
    def as_num(self):
        raise TypeError(
            f&#34;Cannot interpret a {type(self).__name__} as a numeric array&#34;
        )

    @property
    def as_cell(self):
        raise TypeError(
            f&#34;Cannot interpret a {type(self).__name__} as a cell&#34;
        )

    @property
    def as_struct(self):
        raise TypeError(
            f&#34;Cannot interpret a {type(self).__name__} as a struct&#34;
        )

    # TODO: `as_obj` for object arrays?</code></pre>
</details>
<div class="desc"><p>Base class for all matlab-like arrays (numeric, cell, struct).</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="__wrapper__.AnyMatlabArray.as_cell"><code class="name">prop <span class="ident">as_cell</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_cell(self):
    raise TypeError(
        f&#34;Cannot interpret a {type(self).__name__} as a cell&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="__wrapper__.AnyMatlabArray.as_num"><code class="name">prop <span class="ident">as_num</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_num(self):
    raise TypeError(
        f&#34;Cannot interpret a {type(self).__name__} as a numeric array&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="__wrapper__.AnyMatlabArray.as_struct"><code class="name">prop <span class="ident">as_struct</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_struct(self):
    raise TypeError(
        f&#34;Cannot interpret a {type(self).__name__} as a struct&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.MatlabType.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.AnyWrappedArray"><code class="flex name class">
<span>class <span class="ident">AnyWrappedArray</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyWrappedArray(AnyMatlabArray):
    &#34;&#34;&#34;Base class for wrapped numpy/scipy arrays.&#34;&#34;&#34;

    @classmethod
    def _parse_args(cls, *args, **kwargs):
        &#34;&#34;&#34;
        This function is used in the __new__ constructor of Array/Cell/Struct.

        It does some preliminary preprocesing to reduces the number of
        cases that must be handled by __new__.

        In particular:
        - It converts multiple integer arguments to a single list[int]
        - It extracts the shape or object to copy, if there is one.
        - It convert positional dtype/order into keywords.

        Returns
        -------
        mode : {&#34;shape&#34;, &#34;obj&#34;}
        arg : array-like | list[int]
        kwargs : dict
        &#34;&#34;&#34;
        __has_dtype = kwargs.pop(&#34;__has_dtype&#34;, True)
        __has_order = kwargs.pop(&#34;__has_order&#34;, True)

        # Detect integer arguments
        args, shape, obj = list(args), [], None
        while args and isinstance(args[0], int):
            shape.append(args.pop(0))

        # If no integer arguments, the first argument (if it exists)
        # must be a shape or an array-like object to convert.
        if not shape:
            # Catch case where no size/array is passed and the first
            # argument is a data type.
            if args and not isinstance(args[0], (str, np.dtype, type)):
                obj = args.pop(0)

        # If there are positional arguments remaining, they are:
        # 1. dtype
        if args and __has_dtype:
            if &#34;dtype&#34; in kwargs:
                raise TypeError(
                    f&#34;{cls.__name__}() got multiple values for &#34;
                    f&#34;argument &#39;dtype&#39;&#34;
                )
            kwargs[&#34;dtype&#34;] = args.pop(0)
        # 2. order {&#34;C&#34;, &#34;F&#34;}
        if args and __has_order:
            if &#34;order&#34; in kwargs:
                raise TypeError(
                    f&#34;{cls.__name__}() got multiple values for &#34;
                    f&#34;argument &#39;order&#39;&#34;
                )
            kwargs[&#34;order&#34;] = args.pop(0)
        # 3. no other positionals allowed -&gt; raise
        if args:
            raise TypeError(
                f&#34;{cls.__name__}() takes from 1 to 3 positional &#34;
                &#34;arguments but more were given&#34;
            )

        # If we found an object and it is a generator
        # (= an iterable that has no `len`), copy its values into a list.
        if hasattr(obj, &#34;__iter__&#34;) and not hasattr(obj, &#34;__len__&#34;):
            # save iterator values in a list
            obj = list(obj)

        # If obj is a list[int] -&gt; it is a shape
        if (
            not shape and
            isinstance(obj, (list, tuple)) and
            all(isinstance(x, int) for x in obj)
        ):
            shape, obj = obj, None

        mode = &#34;obj&#34; if obj is not None else &#34;shape&#34;
        arg = obj if obj is not None else shape
        return mode, arg, kwargs</code></pre>
</details>
<div class="desc"><p>Base class for wrapped numpy/scipy arrays.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.WrappedArray" href="#__wrapper__.WrappedArray">WrappedArray</a></li>
<li><a title="__wrapper__.WrappedSparseArray" href="#__wrapper__.WrappedSparseArray">WrappedSparseArray</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.AnyMatlabArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.Array"><code class="flex name class">
<span>class <span class="ident">Array</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Array(_ListishMixin, WrappedArray):
    &#34;&#34;&#34;
    Numeric array, compatible with matlab arrays.

    ```python
    # Instantiate from size
    Array(N, M, ...)
    Array([N, M, ...])
    Array.from_shape([N, M, ...])

    # Instantiate from existing numeric array
    Array(other_array)
    Array.from_any(other_array)

    # Other options
    Array(..., dtype=None, order=None, *, copy=None, owndata=None)
    ```

    !!! warning
        Lists or vectors of integers can be interpreted as shapes or as
        numeric arrays to copy. They are interpreted as shapes by the
        `Array` constructor. To ensure that they are interpreted as
        arrays to copy, use `Array.from_any`.
    &#34;&#34;&#34;
    @classmethod
    def _DEFAULT(cls, n: list = ()) -&gt; int:
        return 0

    def __new__(cls, *args, **kwargs) -&gt; &#34;Array&#34;:
        mode, arg, kwargs = cls._parse_args(*args, **kwargs)
        if mode == &#34;shape&#34;:
            obj = super().__new__(cls, shape=arg, **kwargs)
            obj[...] = cls._DEFAULT()
            if not issubclass(obj.dtype.type, np.number):
                raise TypeError(&#34;Array data type must be numeric&#34;)
            return obj
        else:
            return cls.from_any(arg, **kwargs)

    def _as_runtime(self) -&gt; np.ndarray:
        return np.ndarray.view(self, np.ndarray)

    @classmethod
    def _from_runtime(cls, other) -&gt; &#34;Array&#34;:
        other = np.asarray(other)
        if len(other.shape) == 2 and other.shape[0] == 1:
            other = other.squeeze(0)
        return np.ndarray.view(other, cls)

    @classmethod
    def from_shape(cls, shape=tuple(), **kwargs) -&gt; &#34;Array&#34;:
        &#34;&#34;&#34;
        Build an array of a given shape.

        Parameters
        ----------
        shape : list[int]
            Shape of new array.

        Other Parameters
        ----------------
        dtype : np.dtype | None, default=&#39;double&#39;
            Target data type.
        order : {&#34;C&#34;, &#34;F&#34;} | None, default=None
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style);

        Returns
        -------
        array : Array
            New array.
        &#34;&#34;&#34;
        # Implement in __new__ so that array owns its data
        return cls(list(shape), **kwargs)

    @classmethod
    def from_any(cls, other, **kwargs) -&gt; &#34;Array&#34;:
        &#34;&#34;&#34;
        Convert an array-like object to a numeric array.

        Parameters
        ----------
        other : ArrayLike
            object to convert.

        Other Parameters
        ----------------
        dtype : np.dtype | None, default=None
            Target data type. Guessed if `None`.
        order : {&#34;C&#34;, &#34;F&#34;, &#34;A&#34;, &#34;K&#34;} | None, default=None
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style);
            * &#34;A&#34; (any) means &#34;F&#34; if a is Fortran contiguous, &#34;C&#34; otherwise;
            * &#34;K&#34; (keep) preserve input order;
            * `None` preserve input order if possible, &#34;C&#34; otherwise.
        copy : bool | None, default=None
            Whether to copy the underlying data.
            * `True` : the object is copied;
            * `None` : the the object is copied only if needed;
            * `False`: raises a `ValueError` if a copy cannot be avoided.
        owndata : bool, default=None
            If True, ensures that the returned Array owns its data.
            This may trigger an additional copy.

        Returns
        -------
        array : Array
            Converted array.
        &#34;&#34;&#34;
        # prepare for copy
        owndata = kwargs.pop(&#34;owndata&#34;, False)
        copy = None if owndata else kwargs.pop(&#34;copy&#34;, None)
        inp = other

        # ensure array
        other = np.asanyarray(other, **kwargs)
        if not issubclass(other.dtype.type, np.number):
            if kwargs.get(&#34;dtype&#34;, None):
                # user-specified non numeric type -&gt; raise
                raise TypeError(&#34;Array data type must be numeric&#34;)
            other = np.asanyarray(other, dtype=np.float64, **kwargs)

        # view as Array
        other = np.ndarray.view(other, cls)

        # copy (after view so that output owns data if copy=True)
        other = _copy_if_needed(other, inp, copy)

        # take ownership
        if owndata:
            tmp = other
            other = cls(tmp.shape, strides=tmp.strides)
            other[...] = tmp

        return other

    @classmethod
    def from_cell(cls, other: &#34;Cell&#34;, **kwargs) -&gt; &#34;Array&#34;:
        &#34;&#34;&#34;
        Convert a `Cell` to a numeric `Array`.

        Parameters
        ----------
        other : Cell
            Cell to convert.

        Other Parameters
        ----------------
        dtype : np.dtype | None, default=None
            Target data type. Guessed if `None`.
        order : {&#34;C&#34;, &#34;F&#34;, &#34;A&#34;, &#34;K&#34;} | None, default=&#34;K&#34;
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style);
            * &#34;A&#34; (any) means &#34;F&#34; if a is Fortran contiguous, &#34;C&#34; otherwise;
            * &#34;K&#34; (keep) preserve input order.
        owndata : bool, default=None
            If True, ensures that the returned Array owns its data.
            This may trigger an additional copy.

        Returns
        -------
        array : Array
            Converted array.
        &#34;&#34;&#34;
        if not isinstance(other, Cell):
            raise TypeError(f&#34;Expected a {Cell} but got a {type(other)}&#34;)
        order = kwargs.get(&#34;order&#34;, None)
        if order in (None, &#34;K&#34;, &#34;A&#34;):
            order = (
                &#34;F&#34; if other.flags.f_contiguous else
                &#34;C&#34; if other.flags.c_contiguous else
                order)
            kwargs[&#34;order&#34;] = order
        return cls.from_any(other.tolist(), **kwargs)

    @property
    def as_num(self) -&gt; &#34;Array&#34;:
        return self

    def __repr__(self):
        if self.ndim == 0:
            # Scalar -&gt; display as python scalar
            return np.array2string(self, separator=&#34;, &#34;)
        else:
            return super().__repr__()</code></pre>
</details>
<div class="desc"><p>Numeric array, compatible with matlab arrays.</p>
<pre><code class="language-python"># Instantiate from size
Array(N, M, ...)
Array([N, M, ...])
Array.from_shape([N, M, ...])

# Instantiate from existing numeric array
Array(other_array)
Array.from_any(other_array)

# Other options
Array(..., dtype=None, order=None, *, copy=None, owndata=None)
</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Lists or vectors of integers can be interpreted as shapes or as
numeric arrays to copy. They are interpreted as shapes by the
<code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code> constructor. To ensure that they are interpreted as
arrays to copy, use <code><a title="__wrapper__.Array.from_any" href="#__wrapper__.Array.from_any">Array.from_any()</a></code>.</p>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>__wrapper__._ListishMixin</li>
<li><a title="__wrapper__.WrappedArray" href="#__wrapper__.WrappedArray">WrappedArray</a></li>
<li>numpy.ndarray</li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="__wrapper__.Array.from_any"><code class="name flex">
<span>def <span class="ident">from_any</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert an array-like object to a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>object to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np.dtype | None</code>, default=<code>None</code></dt>
<dd>Target data type. Guessed if <code>None</code>.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F", "A", "K"} | None</code>, default=<code>None</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);
* "A" (any) means "F" if a is Fortran contiguous, "C" otherwise;
* "K" (keep) preserve input order;
* <code>None</code> preserve input order if possible, "C" otherwise.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool | None</code>, default=<code>None</code></dt>
<dd>Whether to copy the underlying data.
* <code>True</code> : the object is copied;
* <code>None</code> : the the object is copied only if needed;
* <code>False</code>: raises a <code>ValueError</code> if a copy cannot be avoided.</dd>
<dt><strong><code>owndata</code></strong> :&ensp;<code>bool</code>, default=<code>None</code></dt>
<dd>If True, ensures that the returned Array owns its data.
This may trigger an additional copy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code></dt>
<dd>Converted array.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.Array.from_cell"><code class="name flex">
<span>def <span class="ident">from_cell</span></span>(<span>other: <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a>,<br>**kwargs) ‑> <a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a <code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code> to a numeric <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></dt>
<dd>Cell to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np.dtype | None</code>, default=<code>None</code></dt>
<dd>Target data type. Guessed if <code>None</code>.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F", "A", "K"} | None</code>, default=<code>"K"</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);
* "A" (any) means "F" if a is Fortran contiguous, "C" otherwise;
* "K" (keep) preserve input order.</dd>
<dt><strong><code>owndata</code></strong> :&ensp;<code>bool</code>, default=<code>None</code></dt>
<dd>If True, ensures that the returned Array owns its data.
This may trigger an additional copy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code></dt>
<dd>Converted array.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.Array.from_shape"><code class="name flex">
<span>def <span class="ident">from_shape</span></span>(<span>shape=(), **kwargs) ‑> <a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build an array of a given shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Shape of new array.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np.dtype | None</code>, default=<code>'double'</code></dt>
<dd>Target data type.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F"} | None</code>, default=<code>None</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code></dt>
<dd>New array.</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="__wrapper__.Array.as_num"><code class="name">prop <span class="ident">as_num</span> : <a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_num(self) -&gt; &#34;Array&#34;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="__wrapper__.Cell"><code class="flex name class">
<span>class <span class="ident">Cell</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cell(_ListMixin, WrappedArray):
    &#34;&#34;&#34;
    Cell array, compatible with matlab cells.

    ```python
    # Instantiate from size
    Cell(N, M, ...)
    Cell([N, M, ...])
    Cell.from_shape([N, M, ...])

    # Instantiate from existing (cell-like) array (implicitely)
    Cell(cell_like)
    Cell.from_any(cell_like)

    # Other options
    Cell(..., order=None, *, copy=None, owndata=None, deepcat=False)
    ```

    A cell is a `MutableSequence` and therefore (mostly) behaves like a list.
    It implements the following methods (which all operate along the
    1st dimension, if the cell is a cell array):

    * `append`        : Append object to the end of the cell
    * `clear`         : Empty the cell
    * `count`         : Number of occurrences of a value
    * `extend`        : Extend list by appending elements from the iterable
    * `index`         : First index of a value
    * `insert`        : Insert object before index
    * `pop`           : Remove and return item at index
    * `remove`        : Remove first occurrence of value
    * `reverse`       : Reverse the cell in-place
    * `sort`          : Sort the list in ascending order in-place

    The magic operators `+` and `*` also operate as in lists:

    * `a + b`         : Concatenate `a` and `b`
    * `a += b`        : Append iterable `b` to `a`
    * `a * n`         : Concatenate `n` repeats of `a`
    * `a *= n`        : Append `n` repeats of `a` to `a`

    Finally, elements (along the first dimension) can be deleted using
    `del cell[index]`.

    !!! warning
        Lists or vectors of integers can be interpreted as shapes or as
        cell-like objects to copy. They are interpreted as shapes by the
        `Cell` constructor. To ensure that they are interpreted as
        arrays to copy, use `Cell.from_any`.
    &#34;&#34;&#34;

    # NOTE
    #   _ListMixin must have precedence over _WrappedArray so that its
    #   method overload those from np.ndarray. This is why the
    #   inheritence order is (_ListMixin, _WrappedArray).

    _DelayedType = DelayedCell

    @classmethod
    def _DEFAULT(cls, shape: list = ()) -&gt; np.ndarray:
        data = np.empty(shape, dtype=object)
        opt = dict(
            flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
            op_flags=[&#39;writeonly&#39;, &#39;no_broadcast&#39;]
        )
        with np.nditer(data, **opt) as iter:
            for elem in iter:
                elem[()] = _empty_array()
        return data

    def _fill_default(self):
        arr = np.ndarray.view(self, np.ndarray)
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
                   op_flags=[&#39;writeonly&#39;, &#39;no_broadcast&#39;])
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                elem[()] = _empty_array()
        return self

    def __new__(cls, *args, **kwargs) -&gt; &#34;Cell&#34;:
        mode, arg, kwargs = cls._parse_args(*args, **kwargs)
        kwargs[&#34;dtype&#34;] = object
        if mode == &#34;shape&#34;:
            if len(arg) == 0:
                # Scalar cells are forbidden
                arg = [0]
            return super().__new__(cls, shape=arg, **kwargs)._fill_default()
        else:
            return cls.from_any(arg, **kwargs)

    def _as_runtime(self) -&gt; dict:
        if self.ndim == 1:
            return MatlabType._to_runtime(self.tolist())
        else:
            size = np.array([[*np.shape(self)]])
            data = np.ndarray.view(self, np.ndarray)
            data = np.reshape(data, [-1], order=&#34;F&#34;).tolist()
            data = MatlabType._to_runtime(data)
            return dict(type__=&#39;cell&#39;, size__=size, data__=data)

    @classmethod
    def _from_runtime(cls, objdict: dict) -&gt; &#34;Cell&#34;:
        if isinstance(objdict, (list, tuple, set)):
            shape = [len(objdict)]
            objdict = dict(type__=&#39;cell&#39;, size__=shape, data__=objdict)

        if objdict[&#39;type__&#39;] != &#39;cell&#39;:
            raise TypeError(&#39;objdict is not a cell&#39;)

        size = np.array(objdict[&#39;size__&#39;], dtype=np.uint64).ravel()
        if len(size) == 2 and size[0] == 1:
            # NOTE: should not be needed for Cell, as this should
            # have been taken care of by MPython, but I am keeping it
            # here for symmetry with Array and Struct.
            size = size[1:]
        data = np.fromiter(objdict[&#39;data__&#39;], dtype=object)
        data = data.reshape(size[::-1]).transpose()
        try:
            obj = data.view(cls)
        except Exception:
            raise RuntimeError(
                f&#39;Failed to construct Cell data:\n&#39;
                f&#39;  data={data}\n&#39;
                f&#39;  objdict={objdict}&#39;
            )

        # recurse
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
                   op_flags=[&#39;readwrite&#39;, &#39;no_broadcast&#39;])
        with np.nditer(data, **opt) as iter:
            for elem in iter:
                elem[()] = MatlabType._from_runtime(elem.item())

        return obj

    @classmethod
    def from_shape(cls, shape=tuple(), **kwargs) -&gt; &#34;Cell&#34;:
        &#34;&#34;&#34;
        Build a cell array of a given size.

        Parameters
        ----------
        shape : list[int]
            Input shape.

        Other Parameters
        ----------------
        order : {&#34;C&#34;, &#34;F&#34;} | None, default=&#34;C&#34;
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style).

        Returns
        -------
        cell : Cell
            New cell array.

        &#34;&#34;&#34;
        # Implement in __new__ so that cell owns its data
        return cls(list(shape), **kwargs)

    @classmethod
    def from_any(cls, other, **kwargs) -&gt; &#34;Cell&#34;:
        &#34;&#34;&#34;
        Convert a (nested) list-like object to a cell.

        Parameters
        ----------
        other : CellLike
            object to convert.

        Other Parameters
        ----------------
        deepcat : bool, default=False
            Convert cells of cells into cell arrays.
        order : {&#34;C&#34;, &#34;F&#34;, &#34;A&#34;, &#34;K&#34;} | None, default=None
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style);
            * &#34;A&#34; (any) means &#34;F&#34; if a is Fortran contiguous, &#34;C&#34; otherwise;
            * &#34;K&#34; (keep) preserve input order;
            * `None` preserve input order if possible, &#34;C&#34; otherwise.
        copy : bool | None, default=None
            Whether to copy the underlying data.
            * `True` : the object is copied;
            * `None` : the the object is copied only if needed;
            * `False`: raises a `ValueError` if a copy cannot be avoided.
        owndata : bool, default=False
            If True, ensures that the returned Cell owns its data.
            This may trigger an additional copy.

        Returns
        -------
        cell : Cell
            Converted cell.
        &#34;&#34;&#34;
        # matlab object
        if isinstance(other, dict) and &#34;type__&#34; in other:
            return cls._from_runtime(other)

        kwargs[&#34;dtype&#34;] = object
        deepcat = kwargs.pop(&#34;deepcat&#34;, False)

        # prepare for copy
        owndata = kwargs.pop(&#34;owndata&#34;, False)
        copy = None if owndata else kwargs.pop(&#34;copy&#34;, None)
        inp = other

        # recursive shallow conversion
        if not deepcat:
            # make sure matlab is imported so that we can detect
            # matlab arrays.
            _import_matlab()

            # This is so list[list] are converted to Cell[Cell] and
            # not to a 2D Cell array.
            def asrecursive(other):
                if isinstance(other, tuple(_matlab_array_types())):
                    dtype = _matlab_array_types()[type(other)]
                    other = np.asarray(other, dtype=dtype)
                if isinstance(other, (np.ndarray, AnyDelayedArray)):
                    return other
                elif isinstance(other, (str, bytes)):
                    return other
                elif hasattr(other, &#34;__iter__&#34;):
                    other = list(map(asrecursive, other))
                    tmp = np.ndarray(len(other), dtype=object)
                    for i, x in enumerate(other):
                        tmp[i] = x
                    other = tmp
                    obj = np.ndarray.view(other, cls)
                    return obj
                else:
                    return other

            other = asrecursive(other)

            if not isinstance(other, np.ndarray):
                other = np.asanyarray(other, **kwargs)

        # deep conversion
        else:
            other = np.asanyarray(other, **kwargs)
            other = cls._unroll_build(other)

        # as cell
        other = np.ndarray.view(other, cls)

        # copy (after view so that output owns data if copy=True)
        other = _copy_if_needed(other, inp, copy)

        # take ownership
        if owndata:
            tmp = other
            other = cls(tmp.shape, strides=tmp.strides)
            other[...] = tmp

        # recurse
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
                   op_flags=[&#39;readwrite&#39;, &#39;no_broadcast&#39;])
        with np.nditer(other, **opt) as iter:
            for elem in iter:
                elem[()] = MatlabType.from_any(elem.item())

        return other

    # aliases
    from_num = from_array = from_any

    @classmethod
    def _unroll_build(cls, arr):
        # The logic here is that we may sometimes end up with cells of
        # cells that must be converted to deep cell arrays.
        # To circumvent this, we find elements that are arrays, convert
        # them to lists, and recurse.
        rebuild = False
        arr = np.asarray(arr)
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
                   op_flags=[&#39;readwrite&#39;, &#39;no_broadcast&#39;])
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                item = elem.item()
                if isinstance(item, np.ndarray):
                    item = np.ndarray.view(item, object, np.ndarray)
                    if item.ndim == 0:
                        item = item.item()
                    else:
                        item = item.tolist()
                    elem[()] = item
                    rebuild = True
        if rebuild:
            # Recurse (we may have arrays of arrays of arrays...)
            return cls._unroll_build(arr.tolist())
        return arr

    @property
    def as_cell(self) -&gt; &#34;Cell&#34;:
        return self

    def deepcat(self, owndata=None) -&gt; &#34;Cell&#34;:
        &#34;&#34;&#34;
        Convert a (nested) cell of cells into a deep cell array.
        &#34;&#34;&#34;
        cls = type(self)
        copy = self._unroll_build(np.copy(self))
        copy = np.ndarray.view(copy, cls)

        # take ownership
        if owndata:
            tmp = copy
            copy = cls(tmp.shape, strides=tmp.strides)
            copy[...] = tmp

        return copy

    def __call__(self, *index):
        # We should only use this syntax when accessing elements into an
        # implictely created cell. In that context, we can just defer to
        # square bracket indexing. The point of using round brackets is
        # simply to instruct a DelayedArray that it should transform itself
        # into a Cell.
        #
        # NOTES:
        #
        #   1. We could implement round brackets only in DelayedArrays,
        #      but I like the symmetry of having them in CellArrays too.
        #      It enables things like
        #      ```python
        #      a.b(0).c = &#39;d&#39;  # Instructs that b is a Cell
        #      a.b(1).c = &#39;e&#39;  # At this point b is already a Cell,
        #                      # but it&#39;s nicer to use the same syntax as above
        #      ```
        #
        #   2. This implementation means that using round brackets for
        #      *accessing* data slices (`b(slice(2))`) does not have the
        #      same behaviour as in matlab (`b{1:2}`). This is a very uncommon
        #      use case, though. And single element indexing does work as
        #      expected (python&#39;s `b(1)` == matlab&#39;s `b{2}`).
        #
        #   3. I substitute `slice` with `slice(None)` to make the syntax
        #      for slicing whole axes more compact.
        #
        index = tuple(slice(None) if idx is slice else idx for idx in index)
        return self[index]</code></pre>
</details>
<div class="desc"><p>Cell array, compatible with matlab cells.</p>
<pre><code class="language-python"># Instantiate from size
Cell(N, M, ...)
Cell([N, M, ...])
Cell.from_shape([N, M, ...])

# Instantiate from existing (cell-like) array (implicitely)
Cell(cell_like)
Cell.from_any(cell_like)

# Other options
Cell(..., order=None, *, copy=None, owndata=None, deepcat=False)
</code></pre>
<p>A cell is a <code>MutableSequence</code> and therefore (mostly) behaves like a list.
It implements the following methods (which all operate along the
1st dimension, if the cell is a cell array):</p>
<ul>
<li><code>append</code>
: Append object to the end of the cell</li>
<li><code>clear</code>
: Empty the cell</li>
<li><code>count</code>
: Number of occurrences of a value</li>
<li><code>extend</code>
: Extend list by appending elements from the iterable</li>
<li><code>index</code>
: First index of a value</li>
<li><code>insert</code>
: Insert object before index</li>
<li><code>pop</code>
: Remove and return item at index</li>
<li><code>remove</code>
: Remove first occurrence of value</li>
<li><code>reverse</code>
: Reverse the cell in-place</li>
<li><code>sort</code>
: Sort the list in ascending order in-place</li>
</ul>
<p>The magic operators <code>+</code> and <code>*</code> also operate as in lists:</p>
<ul>
<li><code>a + b</code>
: Concatenate <code>a</code> and <code>b</code></li>
<li><code>a += b</code>
: Append iterable <code>b</code> to <code>a</code></li>
<li><code>a * n</code>
: Concatenate <code>n</code> repeats of <code>a</code></li>
<li><code>a *= n</code>
: Append <code>n</code> repeats of <code>a</code> to <code>a</code></li>
</ul>
<p>Finally, elements (along the first dimension) can be deleted using
<code>del cell[index]</code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Lists or vectors of integers can be interpreted as shapes or as
cell-like objects to copy. They are interpreted as shapes by the
<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code> constructor. To ensure that they are interpreted as
arrays to copy, use <code><a title="__wrapper__.Cell.from_any" href="#__wrapper__.Cell.from_any">Cell.from_any()</a></code>.</p>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>__wrapper__._ListMixin</li>
<li>__wrapper__._ListishMixin</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="__wrapper__.WrappedArray" href="#__wrapper__.WrappedArray">WrappedArray</a></li>
<li>numpy.ndarray</li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>__wrapper__._DictMixin.deal</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="__wrapper__.Cell.from_any"><code class="name flex">
<span>def <span class="ident">from_any</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a (nested) list-like object to a cell.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>CellLike</code></dt>
<dd>object to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>deepcat</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Convert cells of cells into cell arrays.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F", "A", "K"} | None</code>, default=<code>None</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);
* "A" (any) means "F" if a is Fortran contiguous, "C" otherwise;
* "K" (keep) preserve input order;
* <code>None</code> preserve input order if possible, "C" otherwise.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool | None</code>, default=<code>None</code></dt>
<dd>Whether to copy the underlying data.
* <code>True</code> : the object is copied;
* <code>None</code> : the the object is copied only if needed;
* <code>False</code>: raises a <code>ValueError</code> if a copy cannot be avoided.</dd>
<dt><strong><code>owndata</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, ensures that the returned Cell owns its data.
This may trigger an additional copy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cell</code></strong> :&ensp;<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></dt>
<dd>Converted cell.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.Cell.from_array"><code class="name flex">
<span>def <span class="ident">from_array</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a (nested) list-like object to a cell.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>CellLike</code></dt>
<dd>object to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>deepcat</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Convert cells of cells into cell arrays.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F", "A", "K"} | None</code>, default=<code>None</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);
* "A" (any) means "F" if a is Fortran contiguous, "C" otherwise;
* "K" (keep) preserve input order;
* <code>None</code> preserve input order if possible, "C" otherwise.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool | None</code>, default=<code>None</code></dt>
<dd>Whether to copy the underlying data.
* <code>True</code> : the object is copied;
* <code>None</code> : the the object is copied only if needed;
* <code>False</code>: raises a <code>ValueError</code> if a copy cannot be avoided.</dd>
<dt><strong><code>owndata</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, ensures that the returned Cell owns its data.
This may trigger an additional copy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cell</code></strong> :&ensp;<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></dt>
<dd>Converted cell.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.Cell.from_num"><code class="name flex">
<span>def <span class="ident">from_num</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a (nested) list-like object to a cell.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>CellLike</code></dt>
<dd>object to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>deepcat</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Convert cells of cells into cell arrays.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F", "A", "K"} | None</code>, default=<code>None</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);
* "A" (any) means "F" if a is Fortran contiguous, "C" otherwise;
* "K" (keep) preserve input order;
* <code>None</code> preserve input order if possible, "C" otherwise.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool | None</code>, default=<code>None</code></dt>
<dd>Whether to copy the underlying data.
* <code>True</code> : the object is copied;
* <code>None</code> : the the object is copied only if needed;
* <code>False</code>: raises a <code>ValueError</code> if a copy cannot be avoided.</dd>
<dt><strong><code>owndata</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, ensures that the returned Cell owns its data.
This may trigger an additional copy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cell</code></strong> :&ensp;<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></dt>
<dd>Converted cell.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.Cell.from_shape"><code class="name flex">
<span>def <span class="ident">from_shape</span></span>(<span>shape=(), **kwargs) ‑> <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build a cell array of a given size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Input shape.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F"} | None</code>, default=<code>"C"</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cell</code></strong> :&ensp;<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></dt>
<dd>New cell array.</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="__wrapper__.Cell.as_cell"><code class="name">prop <span class="ident">as_cell</span> : <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_cell(self) -&gt; &#34;Cell&#34;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="__wrapper__.Cell.deepcat"><code class="name flex">
<span>def <span class="ident">deepcat</span></span>(<span>self, owndata=None) ‑> <a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcat(self, owndata=None) -&gt; &#34;Cell&#34;:
    &#34;&#34;&#34;
    Convert a (nested) cell of cells into a deep cell array.
    &#34;&#34;&#34;
    cls = type(self)
    copy = self._unroll_build(np.copy(self))
    copy = np.ndarray.view(copy, cls)

    # take ownership
    if owndata:
        tmp = copy
        copy = cls(tmp.shape, strides=tmp.strides)
        copy[...] = tmp

    return copy</code></pre>
</details>
<div class="desc"><p>Convert a (nested) cell of cells into a deep cell array.</p></div>
</dd>
</dl>
</dd>
<dt id="__wrapper__.DelayedArray"><code class="flex name class">
<span>class <span class="ident">DelayedArray</span></span>
<span>(</span><span>shape, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayedArray(WrappedDelayedArray):

    def __init__(self, shape, parent, *index):
        future = Array.from_shape(shape)
        future._delayed_wrapper = self
        super().__init__(future, parent, *index)</code></pre>
</details>
<div class="desc"><p>This is an object that we return when we don't know how an indexed
element will be used yet.</p>
<p>It decides whether it is a Struct, Cell or Array based on the
type of indexing that is used.</p>
<p>In Matlab:
* <code>a(x,y)
= num</code>
indicates that <code>a</code> is a numeric array;
* <code>a(x,y)
= cell</code> indicates that <code>a</code> is a cell array;
* <code>a{x,y}
= any</code>
indicates that <code>a</code> is a cell array;
* <code>a(x,y).f = any</code>
indicates that <code>a</code> is a struct array;
* <code>a.f
= any</code>
indicates that <code>a</code> is a struct.</p>
<p>These indexing operations can be chained, so in
<code>a(x).b.c{y}.d(z) = 2</code>:
* <code>a</code>
is a struct array;
* <code>b</code>
is a struct;
* <code>c</code>
is a cell;
* <code>c{y}</code> is a struct
* <code>d</code>
is a numeric array.</p>
<p>In Python, there is only one type of indexing (<code>[]</code>). This is a problem as
we cannot differentiate <code>a{x}.b = y</code> &ndash; where <code>a</code> is a cell that contains
a struct &ndash; from <code>a(x).b = y</code> &mdash; where <code>a</code> is a struct array.</p>
<p>One solution may be to abuse the "call" operator <code>()</code>, so that it returns a
cell. This would work in some situations (<code>a[x].b = y</code> is a struct array,
whereas <code>a(x).b = y</code> is a cell of struct). However, the statement
<code>a(x) = y</code> (which would correspond to matlab's <code>a{x} = y</code>) is not valid
python syntax. Furthermore, it would induce a new problem, as cells could
not be differentiated from function handles, in some cases.</p>
<p>Instead, the use of brackets automatically transforms the object into
either:
* a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code> (in all "get" cases, and in the "set" context <code>a[x] = y</code>,
when <code>y</code> is either a <code>dict</code> or a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>); or
* a <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code> (in the "set" context <code>a[x] = y</code>, when <code>y</code> is neither a
<code>dict</code> nor a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>).</p>
<p>Alternatively, if the user wishes to specify which type the object should
take, we implement the properties <code>as_cell</code>, <code>as_struct</code> and <code>as_num</code>.</p>
<p>Therefore:
* <code>a[x,y]
= num</code>
: <code>a</code> is a numeric array;
* <code>a[x,y]
= struct</code> : <code>a</code> is a numeric array;
* <code>a[x,y].f
= any</code>
: <code>a</code> is a struct array;
* <code>a(x,y).f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.f
= any</code>
: <code>a</code> is a struct.</p>
<p>And explictly:
* <code>a.as_cell[x,y]
= any</code>
: <code>a</code> is a cell array;
* <code>a.as_struct[x,y].f = any</code>
: <code>a</code> is a struct array;
* <code>a.as_cell[x,y].f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.as_num[x,y]
= num</code>
: <code>a</code> is a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>ndarray | dict</code></dt>
<dd>Reference to the object that will eventually contain
this element.
* If the containing array is a Cell, <code>parent</code> should be a
<code>ndarray</code> view of that cell, and <code>index</code> should be a
[tuple of] int.
* If the containing array is a Struct, <code>parent</code> should be a
<code>dict</code>, and <code>index</code> should be a string.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str | [tuple of] int</code></dt>
<dd>Index into the parent where this element will be inserted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></li>
<li><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.WrappedDelayedArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.DelayedCell"><code class="flex name class">
<span>class <span class="ident">DelayedCell</span></span>
<span>(</span><span>shape, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayedCell(WrappedDelayedArray):

    def __init__(self, shape, parent, *index):
        future = Cell.from_shape(shape)
        future._delayed_wrapper = self
        super().__init__(future, parent, *index)

        # Insert delayed arrays instead of the usual defaults
        opt = dict(
            flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;, &#39;multi_index&#39;],
            op_flags=[&#39;writeonly&#39;, &#39;no_broadcast&#39;]
        )
        arr = np.ndarray.view(self._future, np.ndarray)
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                elem[()] = AnyDelayedArray(self, iter.multi_index)</code></pre>
</details>
<div class="desc"><p>This is an object that we return when we don't know how an indexed
element will be used yet.</p>
<p>It decides whether it is a Struct, Cell or Array based on the
type of indexing that is used.</p>
<p>In Matlab:
* <code>a(x,y)
= num</code>
indicates that <code>a</code> is a numeric array;
* <code>a(x,y)
= cell</code> indicates that <code>a</code> is a cell array;
* <code>a{x,y}
= any</code>
indicates that <code>a</code> is a cell array;
* <code>a(x,y).f = any</code>
indicates that <code>a</code> is a struct array;
* <code>a.f
= any</code>
indicates that <code>a</code> is a struct.</p>
<p>These indexing operations can be chained, so in
<code>a(x).b.c{y}.d(z) = 2</code>:
* <code>a</code>
is a struct array;
* <code>b</code>
is a struct;
* <code>c</code>
is a cell;
* <code>c{y}</code> is a struct
* <code>d</code>
is a numeric array.</p>
<p>In Python, there is only one type of indexing (<code>[]</code>). This is a problem as
we cannot differentiate <code>a{x}.b = y</code> &ndash; where <code>a</code> is a cell that contains
a struct &ndash; from <code>a(x).b = y</code> &mdash; where <code>a</code> is a struct array.</p>
<p>One solution may be to abuse the "call" operator <code>()</code>, so that it returns a
cell. This would work in some situations (<code>a[x].b = y</code> is a struct array,
whereas <code>a(x).b = y</code> is a cell of struct). However, the statement
<code>a(x) = y</code> (which would correspond to matlab's <code>a{x} = y</code>) is not valid
python syntax. Furthermore, it would induce a new problem, as cells could
not be differentiated from function handles, in some cases.</p>
<p>Instead, the use of brackets automatically transforms the object into
either:
* a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code> (in all "get" cases, and in the "set" context <code>a[x] = y</code>,
when <code>y</code> is either a <code>dict</code> or a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>); or
* a <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code> (in the "set" context <code>a[x] = y</code>, when <code>y</code> is neither a
<code>dict</code> nor a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>).</p>
<p>Alternatively, if the user wishes to specify which type the object should
take, we implement the properties <code>as_cell</code>, <code>as_struct</code> and <code>as_num</code>.</p>
<p>Therefore:
* <code>a[x,y]
= num</code>
: <code>a</code> is a numeric array;
* <code>a[x,y]
= struct</code> : <code>a</code> is a numeric array;
* <code>a[x,y].f
= any</code>
: <code>a</code> is a struct array;
* <code>a(x,y).f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.f
= any</code>
: <code>a</code> is a struct.</p>
<p>And explictly:
* <code>a.as_cell[x,y]
= any</code>
: <code>a</code> is a cell array;
* <code>a.as_struct[x,y].f = any</code>
: <code>a</code> is a struct array;
* <code>a.as_cell[x,y].f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.as_num[x,y]
= num</code>
: <code>a</code> is a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>ndarray | dict</code></dt>
<dd>Reference to the object that will eventually contain
this element.
* If the containing array is a Cell, <code>parent</code> should be a
<code>ndarray</code> view of that cell, and <code>index</code> should be a
[tuple of] int.
* If the containing array is a Struct, <code>parent</code> should be a
<code>dict</code>, and <code>index</code> should be a string.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str | [tuple of] int</code></dt>
<dd>Index into the parent where this element will be inserted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></li>
<li><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.WrappedDelayedArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.DelayedStruct"><code class="flex name class">
<span>class <span class="ident">DelayedStruct</span></span>
<span>(</span><span>shape, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelayedStruct(WrappedDelayedArray):

    def __init__(self, shape, parent, *index):
        future = Struct.from_shape(shape)
        future._delayed_wrapper = self
        super().__init__(future, parent, *index)</code></pre>
</details>
<div class="desc"><p>This is an object that we return when we don't know how an indexed
element will be used yet.</p>
<p>It decides whether it is a Struct, Cell or Array based on the
type of indexing that is used.</p>
<p>In Matlab:
* <code>a(x,y)
= num</code>
indicates that <code>a</code> is a numeric array;
* <code>a(x,y)
= cell</code> indicates that <code>a</code> is a cell array;
* <code>a{x,y}
= any</code>
indicates that <code>a</code> is a cell array;
* <code>a(x,y).f = any</code>
indicates that <code>a</code> is a struct array;
* <code>a.f
= any</code>
indicates that <code>a</code> is a struct.</p>
<p>These indexing operations can be chained, so in
<code>a(x).b.c{y}.d(z) = 2</code>:
* <code>a</code>
is a struct array;
* <code>b</code>
is a struct;
* <code>c</code>
is a cell;
* <code>c{y}</code> is a struct
* <code>d</code>
is a numeric array.</p>
<p>In Python, there is only one type of indexing (<code>[]</code>). This is a problem as
we cannot differentiate <code>a{x}.b = y</code> &ndash; where <code>a</code> is a cell that contains
a struct &ndash; from <code>a(x).b = y</code> &mdash; where <code>a</code> is a struct array.</p>
<p>One solution may be to abuse the "call" operator <code>()</code>, so that it returns a
cell. This would work in some situations (<code>a[x].b = y</code> is a struct array,
whereas <code>a(x).b = y</code> is a cell of struct). However, the statement
<code>a(x) = y</code> (which would correspond to matlab's <code>a{x} = y</code>) is not valid
python syntax. Furthermore, it would induce a new problem, as cells could
not be differentiated from function handles, in some cases.</p>
<p>Instead, the use of brackets automatically transforms the object into
either:
* a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code> (in all "get" cases, and in the "set" context <code>a[x] = y</code>,
when <code>y</code> is either a <code>dict</code> or a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>); or
* a <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code> (in the "set" context <code>a[x] = y</code>, when <code>y</code> is neither a
<code>dict</code> nor a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>).</p>
<p>Alternatively, if the user wishes to specify which type the object should
take, we implement the properties <code>as_cell</code>, <code>as_struct</code> and <code>as_num</code>.</p>
<p>Therefore:
* <code>a[x,y]
= num</code>
: <code>a</code> is a numeric array;
* <code>a[x,y]
= struct</code> : <code>a</code> is a numeric array;
* <code>a[x,y].f
= any</code>
: <code>a</code> is a struct array;
* <code>a(x,y).f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.f
= any</code>
: <code>a</code> is a struct.</p>
<p>And explictly:
* <code>a.as_cell[x,y]
= any</code>
: <code>a</code> is a cell array;
* <code>a.as_struct[x,y].f = any</code>
: <code>a</code> is a struct array;
* <code>a.as_cell[x,y].f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.as_num[x,y]
= num</code>
: <code>a</code> is a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>ndarray | dict</code></dt>
<dd>Reference to the object that will eventually contain
this element.
* If the containing array is a Cell, <code>parent</code> should be a
<code>ndarray</code> view of that cell, and <code>index</code> should be a
[tuple of] int.
* If the containing array is a Struct, <code>parent</code> should be a
<code>dict</code>, and <code>index</code> should be a string.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str | [tuple of] int</code></dt>
<dd>Index into the parent where this element will be inserted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></li>
<li><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.WrappedDelayedArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.IndexOrKeyOrAttributeError"><code class="flex name class">
<span>class <span class="ident">IndexOrKeyOrAttributeError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndexOrKeyOrAttributeError(IndexError, KeyError, AttributeError):
    &#34;&#34;&#34;
    Error raised when a non-indexing operation is performed on a
    non-finalized delayed array.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Error raised when a non-indexing operation is performed on a
non-finalized delayed array.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.IndexError</li>
<li>builtins.KeyError</li>
<li>builtins.LookupError</li>
<li>builtins.AttributeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="__wrapper__.MatlabClass"><code class="flex name class">
<span>class <span class="ident">MatlabClass</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatlabClass(MatlabType):
    # FIXME: Can we rename this to `MatlabClass`?

    _subclasses = dict()

    def __new__(cls, *args, _objdict=None, **kwargs):
        if _objdict is None:
            if cls.__name__ in MatlabClass._subclasses.keys():
                obj = Runtime.call(cls.__name__, *args, **kwargs)
            else:
                obj = super().__new__(cls)
        else:
            obj = super().__new__(cls)
            obj._objdict = _objdict
        return obj

    def __init_subclass__(cls):
        super().__init_subclass__()
        if hasattr(cls, &#39;subsref&#39;):
            cls.__getitem__ = MatlabClass.__getitem
            cls.__call__ = MatlabClass.__call

        if hasattr(cls, &#39;subsasgn&#39;):
            cls.__setitem__ = MatlabClass.__setitem

        MatlabClass._subclasses[cls.__name__] = cls

    @classmethod
    def from_any(cls, other) -&gt; &#34;Array&#34;:
        if isinstance(other, dict) and &#34;type__&#34; in other:
            return cls._from_runtime(other)
        if not isinstance(other, cls):
            raise TypeError(f&#34;Cannot convert {type(other)} to {cls}&#34;)
        return other

    @classmethod
    def _from_runtime(cls, objdict):
        if objdict[&#39;class__&#39;] in MatlabClass._subclasses.keys():
            obj = MatlabClass._subclasses[objdict[&#39;class__&#39;]](
                _objdict=objdict
            )
        else:
            warnings.warn(f&#39;Unknown Matlab class type: {objdict[&#34;class__&#34;]}&#39;)
            obj = MatlabClass(_objdict=objdict)
        return obj

    def _as_runtime(self):
        return self._objdict

    def __getattr(self, key):
        try:
            return self.subsref({&#39;type&#39;: &#39;.&#39;, &#39;subs&#39;: key})
        except Exception:
            raise AttributeError(key)

    def __getitem(self, ind):
        index = self._process_index(ind)
        try:
            return self.subsref({&#39;type&#39;: &#39;()&#39;, &#39;subs&#39;: index})
        except Exception:
            ...
        try:
            return self.subsref({&#39;type&#39;: &#39;{}&#39;, &#39;subs&#39;: index})
        except Exception:
            raise IndexError(index)

    def __setitem(self, ind, value):
        index = self._process_index(ind)
        try:
            return self.subsasgn({&#39;type&#39;: &#39;()&#39;, &#39;subs&#39;: index}, value)
        except Exception:
            ...
        try:
            return self.subsasgn({&#39;type&#39;: &#39;{}&#39;, &#39;subs&#39;: index}, value)
        except Exception:
            raise IndexError(index)

    def __call(self, *index):
        index = self._process_index(index)
        try:
            return self.subsref({&#39;type&#39;: &#39;{}&#39;, &#39;subs&#39;: index})
        except Exception:
            raise IndexError(index)

    def _process_index(self, ind, k=1, n=1):
        try:
            return tuple(
                self._process_index(i, k+1, len(ind))
                for k, i in enumerate(ind)
            )
        except TypeError:
            pass

        if not hasattr(self, &#39;__endfn&#39;):
            self.__endfn = Runtime.call(&#39;str2func&#39;, &#39;end&#39;)

        def end():
            return Runtime.call(self.__endfn, self._as_runtime(), k, n)

        if isinstance(ind, int):
            if ind &gt;= 0:
                index = ind + 1
            elif ind == -1:
                index = end()
            else:
                index = end() + ind - 1
        elif isinstance(ind, slice):
            if ind.start is None and ind.stop is None and ind.step is None:
                index = &#39;:&#39;
            else:
                if ind.start is None:
                    start = 1
                elif ind.start &lt; 0:
                    start = end() + ind.start
                else:
                    start = ind.start + 1

                if ind.stop is None:
                    stop = end()
                elif ind.stop &lt; 0:
                    stop = end() + ind.stop
                else:
                    stop = ind.stop + 1

                if ind.step is None:
                    step = 1
                else:
                    step = ind.step

                min_ = min(start, stop)
                max_ = max(start, stop)
                if step &gt; 0:
                    index = np.arange(min_, max_, step)
                else:
                    index = np.arange(max_, min_, step)
        else:
            index = ind

        return index</code></pre>
</details>
<div class="desc"><p>Generic type for objects that have an exact matlab equivalent.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.MatlabType.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.MatlabFunction"><code class="flex name class">
<span>class <span class="ident">MatlabFunction</span></span>
<span>(</span><span>matlab_object)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatlabFunction(MatlabType):
    &#34;&#34;&#34;
    Wrapper for matlab function handles.

    Example
    -------
    ```python
    times2 = Runtime.call(&#34;eval&#34;, &#34;@(x) 2.*x&#34;)
    assert(time2(1) == 2)
    ```
    &#34;&#34;&#34;

    def __init__(self, matlab_object):
        super().__init__()
        if not isinstance(matlab_object, matlab.object):
            raise TypeError(&#34;Expected a matlab.object&#34;)
        self._matlab_object = matlab_object

    def _as_runtime(self):
        return self._matlab_object

    @classmethod
    def _from_runtime(cls, other):
        return cls(other)

    @classmethod
    def from_any(cls, other):
        if isinstance(other, MatlabFunction):
            return other
        return cls._from_runtime(other)

    def __call__(self, *args, **kwargs):
        return Runtime.call(self._matlab_object, *args, **kwargs)</code></pre>
</details>
<div class="desc"><p>Wrapper for matlab function handles.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">times2 = Runtime.call(&quot;eval&quot;, &quot;@(x) 2.*x&quot;)
assert(time2(1) == 2)
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.MatlabType.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.MatlabType"><code class="flex name class">
<span>class <span class="ident">MatlabType</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatlabType(object):
    &#34;&#34;&#34;Generic type for objects that have an exact matlab equivalent.&#34;&#34;&#34;

    @classmethod
    def from_any(cls, other, **kwargs):
        &#34;&#34;&#34;
        Convert python/matlab objects to `MatlabType` objects
        (`Cell`, `Struct`, `Array`, `MatlabClass`).

        !!! warning &#34;Conversion is performed in-place when possible.&#34;
        &#34;&#34;&#34;
        # - we do not convert to matlab&#39;s own array types
        #   (`matlab.double`, etc);
        # - we do not convert to types that can be passed directly to
        #   the matlab runtime;
        # - instead, we convert to python types that mimic matlab types.
        _from_any = partial(cls.from_any, **kwargs)
        _from_runtime = kwargs.pop(&#34;_from_runtime&#34;, False)

        if isinstance(other, MatlabType):
            if isinstance(other, AnyDelayedArray):
                other._error_is_not_finalized()
            return other

        if isinstance(other, dict):
            if &#34;type__&#34; in other:
                type__ = other[&#34;type__&#34;]

                if type__ == &#34;structarray&#34;:
                    # MPython returns a list of dictionaries in data__
                    # and the array shape in size__.
                    return Struct._from_runtime(other)

                elif type__ == &#34;cell&#34;:
                    # MPython returns a list of dictionaries in data__
                    # and the array shape in size__.
                    return Cell._from_runtime(other)

                elif type__ == &#34;object&#34;:
                    # MPython returns the object&#39;s fields serialized
                    # in a dictionary.
                    return MatlabClass._from_runtime(other)

                elif type__ == &#34;sparse&#34;:
                    # MPython returns the coordinates and values in a dict.
                    return SparseArray._from_runtime(other)

                elif type__ == &#34;char&#34;:
                    # Character array that is not a row vector
                    # (row vector are converted to str automatically)
                    # MPython returns all rows in a (F-ordered) cell in data__
                    # Let&#39;s use the cell constructor to return a cellstr.
                    # -&gt; A cellstr is a column vector, not a row vector
                    size = np.asarray(other[&#34;size__&#34;]).tolist()[0]
                    size = size[:-1] + [1]
                    other[&#34;type__&#34;] = &#34;cell&#34;
                    other[&#34;size__&#34;] = np.asarray([size])
                    return Cell._from_runtime(other)

                else:
                    raise ValueError(&#34;Don&#39;t know what to do with type&#34;, type__)

            else:
                other = type(other)(
                    zip(other.keys(),
                        map(_from_any, other.values()))
                )
                return Struct.from_any(other)

        if isinstance(other, (list, tuple, set)):
            # nested tuples are cells of cells, not cell arrays
            if _from_runtime:
                return Cell._from_runtime(other)
            else:
                return Cell.from_any(other)

        if isinstance(other, (np.ndarray, int, float, complex, bool)):
            # [array of] numbers -&gt; Array
            if _from_runtime:
                return Array._from_runtime(other)
            else:
                return Array.from_any(other)

        if isinstance(other, str):
            return other

        if isinstance(other, bytes):
            return other.decode()

        if other is None:
            # This can happen when matlab code is called without `nargout`
            return other

        if not matlab:
            _import_matlab()

        if matlab and isinstance(other, matlab.object):
            return MatlabFunction.from_any(other)

        if type(other) in _matlab_array_types():
            return Array._from_runtime(other)

        if hasattr(other, &#34;__iter__&#34;):
            # Iterable -&gt; let&#39;s try to make it a cell
            return cls.from_any(list(other), _from_runtime=_from_runtime)

        raise TypeError(
            f&#34;Cannot convert {type(other)} into a matlab object.&#34;
        )

    @classmethod
    def _from_runtime(cls, obj):
        return cls.from_any(obj, _from_runtime=True)

    @classmethod
    def _to_runtime(cls, obj):
        &#34;&#34;&#34;
        Convert object to representation that the matlab runtime understands.
        &#34;&#34;&#34;
        to_runtime = cls._to_runtime

        if isinstance(obj, MatlabType):
            # class / structarray / cell
            return obj._as_runtime()

        elif isinstance(obj, (list, tuple, set)):
            return type(obj)(map(to_runtime, obj))

        elif isinstance(obj, dict):
            if &#34;type__&#34; in obj:
                return obj
            return type(obj)(zip(obj.keys(), map(to_runtime, obj.values())))

        elif isinstance(obj, np.ndarray):
            obj = np.asarray(obj)
            if obj.dtype in (object, dict):
                shape, dtype = obj.shape, obj.dtype
                obj = np.fromiter(map(to_runtime, obj.flat), dtype=dtype)
                obj = obj.reshape(shape)
                return obj.tolist()
            return obj

        elif sparse and isinstance(obj, sparse.sparray):
            return SparseArray.from_any(obj)._as_runtime()

        else:
            # TODO: do we want to raise if the type is not supported by matlab?
            #
            # Valid types for matlab bindings:
            #   - bool, int, float, complex, str, bytes, bytearray
            #
            # Valid matlab types that we have already dealt with:
            #   - list, tuple, set, dict, ndarray
            #
            # All other values/types are invalid (including `None`!)
            return obj

    def _as_runtime(self):
        raise NotImplementedError

    def _as_matlab_object(self):
        # Backward compatibility
        # FIXME: Or just keep `_as_matlab_object` and remove `_as_runtime`?
        return self._as_runtime()</code></pre>
</details>
<div class="desc"><p>Generic type for objects that have an exact matlab equivalent.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabClass" href="#__wrapper__.MatlabClass">MatlabClass</a></li>
<li><a title="__wrapper__.MatlabFunction" href="#__wrapper__.MatlabFunction">MatlabFunction</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="__wrapper__.MatlabType.from_any"><code class="name flex">
<span>def <span class="ident">from_any</span></span>(<span>other, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert python/matlab objects to <code><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></code> objects
(<code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code>, <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>, <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code>, <code><a title="__wrapper__.MatlabClass" href="#__wrapper__.MatlabClass">MatlabClass</a></code>).</p>
<div class="admonition warning">
<p class="admonition-title">Conversion is performed in-place when possible.</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="__wrapper__.Runtime"><code class="flex name class">
<span>class <span class="ident">Runtime</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Runtime:
    &#34;&#34;&#34;Namespace that holds the matlab runtime. All methods are static.&#34;&#34;&#34;

    _initialize = None
    _instance = None
    verbose = True

    @staticmethod
    def instance():
        if Runtime._instance is None:
            if Runtime.verbose:
                print(&#39;Initializing Matlab Runtime...&#39;)
            Runtime._import_initialize()
            Runtime._instance = Runtime._initialize()
        return Runtime._instance

    @staticmethod
    def call(fn, *args, **kwargs):
        (args, kwargs) = Runtime._process_argin(*args, **kwargs)
        res = Runtime.instance().mpython_endpoint(fn, *args, **kwargs)
        return Runtime._process_argout(res)

    @staticmethod
    def _process_argin(*args, **kwargs):
        to_runtime = MatlabType._to_runtime
        args = tuple(map(to_runtime, args))
        kwargs = dict(zip(kwargs.keys(), map(to_runtime, kwargs.values())))
        return args, kwargs

    @staticmethod
    def _process_argout(res):
        return MatlabType.from_any(res)

    @staticmethod
    def _import_initialize():
        # NOTE(YB)
        #   I moved the import within a function so that array wrappers
        #   can be imported and used even when matlab is not properly setup.
        if Runtime._initialize:
            return
        try:
            from spm._spm import initialize
            Runtime._initialize = initialize
        except ImportError as e:
            # ~~~ UNUSED ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # import os
            # installer_path = os.path.join(
            #     os.path.dirname(os.path.abspath(__file__)),
            #     &#39;_spm&#39;,
            #     &#39;resources&#39;,
            #     &#39;RuntimeInstaller.install&#39;
            # )
            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            print(Runtime._help)
            raise e
        # Make sure matlab is imported
        _import_matlab()

    _help = &#34;&#34;&#34;
    Failed to import spm._spm. This can be due to a failure to find Matlab
    Runtime. Please verify that Matlab Runtime is installed and its path is set.
    See https://www.mathworks.com/help/compiler/mcr-path-settings-for-run-time-deployment.html
    for instructions on how to setup the path.
    If the issue persists, please open an issue with the entire error
    message at https://github.com/spm/spm-python/issues.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Namespace that holds the matlab runtime. All methods are static.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="__wrapper__.Runtime.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="__wrapper__.Runtime.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>fn, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def call(fn, *args, **kwargs):
    (args, kwargs) = Runtime._process_argin(*args, **kwargs)
    res = Runtime.instance().mpython_endpoint(fn, *args, **kwargs)
    return Runtime._process_argout(res)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="__wrapper__.Runtime.instance"><code class="name flex">
<span>def <span class="ident">instance</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def instance():
    if Runtime._instance is None:
        if Runtime.verbose:
            print(&#39;Initializing Matlab Runtime...&#39;)
        Runtime._import_initialize()
        Runtime._instance = Runtime._initialize()
    return Runtime._instance</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="__wrapper__.SparseArray"><code class="flex name class">
<span>class <span class="ident">SparseArray</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SparseArray(sparse.csc_array, _SparseMixin, WrappedSparseArray):
    &#34;&#34;&#34;
    Matlab sparse arrays (scipy.sparse backend).

    ```python
    # Instantiate from size
    SparseArray(N, M, ...)
    SparseArray([N, M, ...])
    SparseArray.from_shape([N, M, ...])

    # Instantiate from existing sparse or dense array
    SparseArray(other_array)
    SparseArray.from_any(other_array)

    # Other options
    SparseArray(..., dtype=None, *, copy=None)
    ```

    !!! warning
        Lists or vectors of integers can be interpreted as shapes
        or as dense arrays to copy. They are interpreted as shapes
        by the `SparseArray` constructor. To ensure that they are
        interpreted as dense arrays to copy, usse `SparseArray.from_any`.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs) -&gt; None:
        mode, arg, kwargs = self._parse_args(*args, **kwargs)
        if mode == &#34;shape&#34;:
            ndim = len(arg)
            return super().__init__(([], [[]]*ndim), shape=arg, **kwargs)
        else:
            if not isinstance(arg, (np.ndarray, sparse.sparray)):
                arg = np.asanyarray(arg)
            return super().__init__(arg, **kwargs)

    @classmethod
    def from_coo(cls, values, indices, shape=None, **kw) -&gt; &#34;SparseArray&#34;:
        &#34;&#34;&#34;
        Build a sparse array from indices and values.

        Parameters
        ----------
        values : (N,) ArrayLike
            Values to set at each index.
        indices : (D, N) ArrayLike
            Indices of nonzero elements.
        shape : list[int] | None
            Shape of the array.
        dtype : np.dtype | None
            Target data type. Same as `values` by default.

        Returns
        -------
        array : SparseArray
            New array.
        &#34;&#34;&#34;
        indices = np.asarray(indices)
        coo = sparse.coo_array((values, indices), shape=shape, **kw)
        return cls.from_any(coo)

    @classmethod
    def from_shape(cls, shape=tuple(), **kwargs) -&gt; &#34;SparseArray&#34;:
        &#34;&#34;&#34;
        Build an array of a given shape.

        Parameters
        ----------
        shape : list[int]
            Shape of the new array.

        Other Parameters
        ----------------
        dtype : np.dtype | None, default=&#39;double&#39;
            Target data type.

        Returns
        -------
        array : SparseArray
            New array.
        &#34;&#34;&#34;
        return cls(list(shape), **kwargs)

    @classmethod
    def from_any(cls, other, **kwargs) -&gt; &#34;SparseArray&#34;:
        &#34;&#34;&#34;
        Convert an array-like object to a numeric array.

        Parameters
        ----------
        other : ArrayLike
            object to convert.

        Other Parameters
        ----------------
        dtype : np.dtype | None, default=None
            Target data type. Guessed if `None`.
        copy : bool | None, default=None
            Whether to copy the underlying data.
            * `True` : the object is copied;
            * `None` : the the object is copied only if needed;
            * `False`: raises a `ValueError` if a copy cannot be avoided.

        Returns
        -------
        array : SparseArray
            Converted array.
        &#34;&#34;&#34;
        copy = kwargs.pop(&#34;copy&#34;, None)
        inp = other
        if not isinstance(other, sparse.sparray):
            other = np.asanyarray(other, **kwargs)
        other = cls(other, **kwargs)
        other = _spcopy_if_needed(other, inp, copy)
        return other</code></pre>
</details>
<div class="desc"><p>Matlab sparse arrays (scipy.sparse backend).</p>
<pre><code class="language-python"># Instantiate from size
SparseArray(N, M, ...)
SparseArray([N, M, ...])
SparseArray.from_shape([N, M, ...])

# Instantiate from existing sparse or dense array
SparseArray(other_array)
SparseArray.from_any(other_array)

# Other options
SparseArray(..., dtype=None, *, copy=None)
</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Lists or vectors of integers can be interpreted as shapes
or as dense arrays to copy. They are interpreted as shapes
by the <code><a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></code> constructor. To ensure that they are
interpreted as dense arrays to copy, usse <code><a title="__wrapper__.SparseArray.from_any" href="#__wrapper__.SparseArray.from_any">SparseArray.from_any()</a></code>.</p>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scipy.sparse._csc.csc_array</li>
<li>scipy.sparse._csc._csc_base</li>
<li>scipy.sparse._compressed._cs_matrix</li>
<li>scipy.sparse._data._data_matrix</li>
<li>scipy.sparse._base._spbase</li>
<li>scipy.sparse._data._minmax_mixin</li>
<li>scipy.sparse._index.IndexMixin</li>
<li>__wrapper__._SparseMixin</li>
<li><a title="__wrapper__.WrappedSparseArray" href="#__wrapper__.WrappedSparseArray">WrappedSparseArray</a></li>
<li>scipy.sparse._base.sparray</li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="__wrapper__.SparseArray.from_any"><code class="name flex">
<span>def <span class="ident">from_any</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert an array-like object to a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>object to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np.dtype | None</code>, default=<code>None</code></dt>
<dd>Target data type. Guessed if <code>None</code>.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool | None</code>, default=<code>None</code></dt>
<dd>Whether to copy the underlying data.
* <code>True</code> : the object is copied;
* <code>None</code> : the the object is copied only if needed;
* <code>False</code>: raises a <code>ValueError</code> if a copy cannot be avoided.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></code></dt>
<dd>Converted array.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.SparseArray.from_coo"><code class="name flex">
<span>def <span class="ident">from_coo</span></span>(<span>values, indices, shape=None, **kw) ‑> <a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build a sparse array from indices and values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>(N,) ArrayLike</code></dt>
<dd>Values to set at each index.</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>(D, N) ArrayLike</code></dt>
<dd>Indices of nonzero elements.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int] | None</code></dt>
<dd>Shape of the array.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np.dtype | None</code></dt>
<dd>Target data type. Same as <code>values</code> by default.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></code></dt>
<dd>New array.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.SparseArray.from_shape"><code class="name flex">
<span>def <span class="ident">from_shape</span></span>(<span>shape=(), **kwargs) ‑> <a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build an array of a given shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Shape of the new array.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>dtype</code></strong> :&ensp;<code>np.dtype | None</code>, default=<code>'double'</code></dt>
<dd>Target data type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></code></dt>
<dd>New array.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="__wrapper__.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Struct(_DictMixin, WrappedArray):
    &#34;&#34;&#34;
    Struct array, compatible with matlab structs.

    ```python
    # Instantiate from size
    Struct(N, M, ...)
    Struct([N, M, ...])
    Struct.from_shape([N, M, ...])

    # Instantiate from existing struct array
    # (or list/cell of dictionaries)
    Struct(struct_like)
    Struct.from_any(struct_like)

    # Instantiate from dictionary
    Struct(a=x, b=y)
    Struct({&#34;a&#34;: x, &#34;b&#34;: y})
    Struct.from_any({&#34;a&#34;: x, &#34;b&#34;: y})
    ```

    The following field names correspond to existing attributes or
    methods of `Struct` objects and are therefore protected. They can
    still be used as field names, but only through the dictionary syntax
    (`s[&#34;shape&#34;]`), not the dot syntax (`s.shape`):

    * `ndim -&gt; int`            : number of dimensions
    * `shape -&gt; list[int]`     : array shape
    * `size -&gt; int`            : number of elements
    * `reshape() -&gt; Struct`    : struct array with a different shape
    * `keys() -&gt; list[str]`    : field names
    * `values() -&gt; list`       : values (per key)
    * `items() -&gt; [str, list]` : (key, value) pairs
    * `get() -&gt; list`          : value (per element)
    * `setdefault()`           : sets default value for field name
    * `update()`               : update fields from dictionary-like
    * `as_num -&gt; raise`        : interpret object as a numeric array
    * `as_cell -&gt; raise`       : interpret object as a cell array
    * `as_struct -&gt; Struct`    : interpret object as a struct array
    * `as_dict() -&gt; dict`      : convert to plain dictionary
    * `from_shape() -&gt; Struct` : build a new empty struct
    * `from_any() -&gt; Struct`   : build a new struct by (shallow) copy
    * `from_cell() -&gt; Struct`  : build a new struct by (shallow) copy

    The following field names are protected because they have a special
    meaning in the python language. They can still be used as field names
    through the dictionary syntax:
    `as`        `assert`    `break`     `class`     `continue`  `def`
    `del`       `elif`      `else`      `except`    `False`     `finally`
    `for`       `from`      `global`    `if`        `import`    `in`
    `is`        `lambda`    `None`      `nonlocal`  `not`       `or`
    `pass`      `raise`     `return`    `True`      `try`       `while`
    `with`      `yield`
    &#34;&#34;&#34;

    # NOTE
    #   _DictMixin must have precedence over _WrappedArray so that its
    #   method overload those from np.ndarray. This is why the
    #   inheritence order is (_DictMixin, _WrappedArray).

    # List of public attributes and methods from the ndarray class that
    # we keep in Struct. I&#39;ve tried to find the minimal set of attributes
    # required to not break the numpy api.
    _NDARRAY_ATTRS = (&#34;ndim&#34;, &#34;shape&#34;, &#34;size&#34;, &#34;reshape&#34;)

    _DelayedType = DelayedStruct

    @classmethod
    def _DEFAULT(self, shape: list = ()) -&gt; np.ndarray:
        # if len(shape) == 0:
        #     out = np.array(None)
        #     out[()] = dict()
        #     return out

        data = np.empty(shape, dtype=dict)
        opt = dict(
            flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
            op_flags=[&#39;writeonly&#39;, &#39;no_broadcast&#39;]
        )
        with np.nditer(data, **opt) as iter:
            for elem in iter:
                elem[()] = dict()
        return data

    def _fill_default(self):
        arr = np.ndarray.view(self, np.ndarray)
        flags = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readwrite&#39;])
        with np.nditer(arr, **flags) as iter:
            for elem in iter:
                elem[()] = dict()
        return self

    def __new__(cls, *args, **kwargs) -&gt; &#34;Struct&#34;:
        kwargs[&#34;__has_dtype&#34;] = False
        kwargs[&#34;__has_order&#34;] = False
        mode, arg, kwargs = cls._parse_args(*args, **kwargs)
        if mode == &#34;shape&#34;:
            obj = super().__new__(cls, shape=arg, dtype=dict)._fill_default()
        else:
            obj = cls.from_any(arg)
        obj.update(kwargs)
        return obj

    def _as_runtime(self) -&gt; dict:
        if self.ndim == 0:
            data = np.ndarray.view(self, np.ndarray).item()
            data = MatlabType._to_runtime(data)
            return data

        size = np.array([[*np.shape(self)]])
        data = np.ndarray.view(self, np.ndarray)
        data = np.reshape(data, [-1], order=&#34;F&#34;)
        data = MatlabType._to_runtime(data)
        return dict(type__=&#39;structarray&#39;, size__=size, data__=data)

    @classmethod
    def _from_runtime(cls, objdict: dict) -&gt; &#34;Struct&#34;:
        if objdict[&#39;type__&#39;] != &#39;structarray&#39;:
            raise TypeError(&#39;objdict is not a structarray&#39;)
        size = np.array(objdict[&#39;size__&#39;], dtype=np.uint64).ravel()
        if len(size) == 2 and size[0] == 1:
            # NOTE: should not be needed for Cell, as this should
            # have been taken care of by MPython, but I am keeping it
            # here for symmetry with Array and Struct.
            size = size[1:]
        data = np.array(objdict[&#39;data__&#39;], dtype=object)
        data = data.reshape(size)
        try:
            obj = data.view(cls)
        except Exception:
            raise RuntimeError(
                f&#39;Failed to construct Struct data:\n&#39;
                f&#39;  data={data}\n&#39;
                f&#39;  objdict={objdict}&#39;
            )

        # recurse
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;],
                   op_flags=[&#39;readonly&#39;, &#39;no_broadcast&#39;])
        with np.nditer(data, **opt) as iter:
            for elem in iter:
                item = elem.item()
                for key, val in item.items():
                    item[key] = MatlabType._from_runtime(val)

        return obj

    @classmethod
    def from_shape(cls, shape=tuple(), **kwargs) -&gt; &#34;Struct&#34;:
        &#34;&#34;&#34;
        Build a struct array of a given size.

        Parameters
        ----------
        shape : list[int]
            Input shape.

        Other Parameters
        ----------------
        order : {&#34;C&#34;, &#34;F&#34;} | None, default=&#34;C&#34;
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style).

        Returns
        -------
        struct : Struct
            New struct array.

        &#34;&#34;&#34;
        return cls(list(shape), **kwargs)

    @classmethod
    def from_any(cls, other, **kwargs) -&gt; &#34;Struct&#34;:
        &#34;&#34;&#34;
        * Convert a dict-like object to struct; or
        * Convert an array of dict-like objects to a struct array.

        Parameters
        ----------
        other : DictLike | ArrayLike[DictLike]
            object to convert.

        Other Parameters
        ----------------
        order : {&#34;C&#34;, &#34;F&#34;, &#34;A&#34;, &#34;K&#34;} | None, default=None
            Memory layout.
            * &#34;C&#34; row-major (C-style);
            * &#34;F&#34; column-major (Fortran-style);
            * &#34;A&#34; (any) means &#34;F&#34; if a is Fortran contiguous, &#34;C&#34; otherwise;
            * &#34;K&#34; (keep) preserve input order;
            * `None` preserve input order if possible, &#34;C&#34; otherwise.
        copy : bool | None, default=None
            Whether to copy the underlying data.
            * `True` : the object is copied;
            * `None` : the the object is copied only if needed;
            * `False`: raises a `ValueError` if a copy cannot be avoided.
        owndata : bool, default=None
            If True, ensures that the returned Struct owns its data.
            This may trigger an additional copy.

        Returns
        -------
        struct : Struct
            Converted structure.
        &#34;&#34;&#34;
        if isinstance(other, dict) and &#34;type__&#34; in other:
            # matlab object
            return cls._from_runtime(other)

        kwargs[&#34;dtype&#34;] = dict

        # prepare for copy
        owndata = kwargs.pop(&#34;owndata&#34;, False)
        copy = None if owndata else kwargs.pop(&#34;copy&#34;, None)
        inp = other

        # convert to array[dict]
        other = np.asanyarray(other, **kwargs)
        other = cls._unroll_build(other)

        # check all items are dictionaries
        arr = np.ndarray.view(other, np.ndarray)
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readonly&#39;])
        with np.nditer(arr, **opt) as iter:
            if not all(isinstance(elem.item(), dict) for elem in iter):
                raise TypeError(&#34;Not an array of dictionaries&#34;)

        # view as Struct
        other = np.ndarray.view(other, cls)

        # copy (after view so that output owns data if copy=True)
        other = _copy_if_needed(other, inp, copy)

        # take ownership
        if owndata:
            tmp = other
            other = cls(tmp.shape, dtype=tmp.dtype, strides=tmp.strides)
            other[...] = tmp

        # nested from_any
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readonly&#39;])
        with np.nditer(other, **opt) as iter:
            for elem in iter:
                item: dict = elem.item()
                for k, v in item.items():
                    item[k] = MatlabType.from_any(v)

        return other

    @classmethod
    def from_cell(cls, other, **kwargs) -&gt; &#34;Struct&#34;:
        &#34;&#34;&#34;See `from_any`.&#34;&#34;&#34;
        if not isinstance(other, Cell):
            raise TypeError(f&#34;Expected a {Cell} but got a {type(other)}.&#34;)
        return cls.from_any(other, **kwargs)

    @classmethod
    def _unroll_build(cls, other):
        # The logic here is that we may sometimes end up with arrays of
        # arrays of dict rather than a single deep array[dict]
        # (for example when converting cells of cells of dict).
        # To circumvent this, we find elements that are arrays, convert
        # them to lists, and recurse.
        rebuild = False
        arr = np.ndarray.view(other, np.ndarray)
        flags = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readwrite&#39;])
        with np.nditer(arr, **flags) as iter:
            for elem in iter:
                item = elem.item()
                if isinstance(item, np.ndarray):
                    item = np.ndarray.view(item, dict, np.ndarray)
                    if item.ndim == 0:
                        item = item.item()
                    else:
                        item = item.tolist()
                    elem[()] = item
                    rebuild = True
        if rebuild:
            # Recurse (we may have arrays of arrays of arrays...)
            return cls._unroll_build(other)
        return other

    @property
    def as_struct(self) -&gt; &#34;Struct&#34;:
        return self

    def __repr__(self):
        if self.ndim == 0:
            # Scalar struct -&gt; display as a dict
            return repr(np.ndarray.view(self, np.ndarray).item())
        else:
            return super().__repr__()

    def as_dict(self, keys=None) -&gt; dict:
        &#34;&#34;&#34;
        Convert the object into a plain dict.

        * If a struct, return the underlying dict (no copy, is a view)
        * If a struct array, return a dict of Cell (copy, not a view)
        &#34;&#34;&#34;
        self._ensure_defaults_are_set(keys)

        # NOTE
        #   The `keys` argument is only used in `__getattr__` to avoid
        #   building the entire dictionary, when the content of a single
        #   key is eventually used.

        # scalar struct -&gt; return the underlying dictionary
        arr = np.ndarray.view(self, np.ndarray)

        if arr.ndim == 0:
            asdict = arr.item()
            if keys is not None:
                asdict = {key: asdict[key] for key in keys}
            return asdict

        # otherwise     -&gt; reverse array/dict order -&gt; dict of cells of values

        if keys is None:
            keys = self._allkeys()
        elif isinstance(keys, str):
            keys = [keys]

        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readwrite&#39;])
        asdict = {key: [] for key in keys}
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                item = elem.item()
                for key in keys:
                    asdict[key].append(item[key])
        for key in keys:
            asdict[key] = Cell.from_any(asdict[key])
        raise ValueError(keys)
        return asdict

    def _allkeys(self):
        # Return all keys present across all elements.
        # Keys are ordered by (1) element (2) within-element order
        mock = {}
        arr = np.ndarray.view(self, np.ndarray)
        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readonly&#39;])
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                mock.update({key: None for key in elem.item().keys()})
        return mock.keys()

    def _ensure_defaults_are_set(self, keys=None):
        &#34;&#34;&#34;
        If a new key is set in an array element, this function ensures
        that all other elements are assigned a default value in the new key.
        &#34;&#34;&#34;
        arr = np.ndarray.view(self, np.ndarray)

        if arr.ndim == 0:
            if keys:
                item: dict = arr.item()
                for key in keys:
                    item.setdefault(key, _empty_array())

        if keys is None:
            keys = self._allkeys()
        elif isinstance(keys, str):
            keys = [keys]

        opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readonly&#39;])
        with np.nditer(arr, **opt) as iter:
            for elem in iter:
                item: dict = elem.item()
                for key in keys:
                    item.setdefault(key, _empty_array())

    # --------------
    # Bracket syntax
    # --------------

    def __getitem__(self, index):
        if isinstance(index, str):
            try:
                return getattr(self, index)
            except AttributeError as e:
                raise KeyError(str(e))
        else:
            obj = WrappedArray.__getitem__(self, index)
            if not isinstance(obj, (Struct, DelayedStruct)):
                # We&#39;ve indexed a single element, but we do not want
                # to expose the underlying dictionary. Instead,
                # we return an empty-sized view of the element, which
                # is still of type `Struct`.
                if not isinstance(index, tuple):
                    index = (index,)
                index += (None,)
                obj = np.ndarray.__getitem__(self, index)
                obj = np.reshape(obj, [])
            return obj

    def __setitem__(self, index, value):
        value = MatlabType.from_any(value)
        if isinstance(index, str):
            setattr(self, index, value)
        else:
            WrappedArray.__setitem__(self, index, value)
        self._ensure_defaults_are_set()

    def __delitem__(self, index):
        if isinstance(index, str):
            try:
                return delattr(self, index)
            except AttributeError as e:
                raise KeyError(str(e))
        return WrappedArray.__delitem__(self, index)

    # ----------
    # Dot syntax
    # ----------

    def __getattribute__(self, key):
        # Hide public numpy attributes
        asnumpy = np.ndarray.view(self, np.ndarray)
        if (
            hasattr(asnumpy, key) and key[:1] != &#34;_&#34; and
            key not in type(self)._NDARRAY_ATTRS
        ):
            raise AttributeError(f&#34;hide numpy.ndarray.{key}&#34;)
        return super().__getattribute__(key)

    def __getattr__(self, key):
        if key[:1] == &#34;_&#34;:
            raise AttributeError(
                f&#34;{type(self).__name__} object has no attribute &#39;{key}&#39;&#34;
            )
        try:
            return _DictMixin.__getitem__(self, key)
        except KeyError as e:
            raise AttributeError(str(e))

    def __setattr__(self, key, value):
        if key[:1] == &#34;_&#34;:
            super().__setattr__(key, value)
            self._ensure_defaults_are_set()
            return
        try:
            _DictMixin.__setitem__(self, key, value)
            self._ensure_defaults_are_set()
            return
        except KeyError as e:
            raise AttributeError(str(e))

    def __delattr__(self, key):
        if key[:1] == &#34;_&#34;:
            return super().__delattr__(key)
        try:
            return _DictMixin.__delitem__(self, key)
        except KeyError as e:
            raise AttributeError(str(e))</code></pre>
</details>
<div class="desc"><p>Struct array, compatible with matlab structs.</p>
<pre><code class="language-python"># Instantiate from size
Struct(N, M, ...)
Struct([N, M, ...])
Struct.from_shape([N, M, ...])

# Instantiate from existing struct array
# (or list/cell of dictionaries)
Struct(struct_like)
Struct.from_any(struct_like)

# Instantiate from dictionary
Struct(a=x, b=y)
Struct({&quot;a&quot;: x, &quot;b&quot;: y})
Struct.from_any({&quot;a&quot;: x, &quot;b&quot;: y})
</code></pre>
<p>The following field names correspond to existing attributes or
methods of <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code> objects and are therefore protected. They can
still be used as field names, but only through the dictionary syntax
(<code>s["shape"]</code>), not the dot syntax (<code>s.shape</code>):</p>
<ul>
<li><code>ndim -&gt; int</code>
: number of dimensions</li>
<li><code>shape -&gt; list[int]</code>
: array shape</li>
<li><code>size -&gt; int</code>
: number of elements</li>
<li><code>reshape() -&gt; Struct</code>
: struct array with a different shape</li>
<li><code>keys() -&gt; list[str]</code>
: field names</li>
<li><code>values() -&gt; list</code>
: values (per key)</li>
<li><code>items() -&gt; [str, list]</code> : (key, value) pairs</li>
<li><code>get() -&gt; list</code>
: value (per element)</li>
<li><code>setdefault()</code>
: sets default value for field name</li>
<li><code>update()</code>
: update fields from dictionary-like</li>
<li><code>as_num -&gt; raise</code>
: interpret object as a numeric array</li>
<li><code>as_cell -&gt; raise</code>
: interpret object as a cell array</li>
<li><code>as_struct -&gt; Struct</code>
: interpret object as a struct array</li>
<li><code>as_dict() -&gt; dict</code>
: convert to plain dictionary</li>
<li><code>from_shape() -&gt; Struct</code> : build a new empty struct</li>
<li><code>from_any() -&gt; Struct</code>
: build a new struct by (shallow) copy</li>
<li><code>from_cell() -&gt; Struct</code>
: build a new struct by (shallow) copy</li>
</ul>
<p>The following field names are protected because they have a special
meaning in the python language. They can still be used as field names
through the dictionary syntax:
<code>as</code>
<code>assert</code>
<code>break</code>
<code>class</code>
<code>continue</code>
<code>def</code>
<code>del</code>
<code>elif</code>
<code>else</code>
<code>except</code>
<code>False</code>
<code>finally</code>
<code>for</code>
<code>from</code>
<code>global</code>
<code>if</code>
<code>import</code>
<code>in</code>
<code>is</code>
<code>lambda</code>
<code>None</code>
<code>nonlocal</code>
<code>not</code>
<code>or</code>
<code>pass</code>
<code>raise</code>
<code>return</code>
<code>True</code>
<code>try</code>
<code>while</code>
<code>with</code>
<code>yield</code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>__wrapper__._DictMixin</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="__wrapper__.WrappedArray" href="#__wrapper__.WrappedArray">WrappedArray</a></li>
<li>numpy.ndarray</li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="__wrapper__.Struct.from_any"><code class="name flex">
<span>def <span class="ident">from_any</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>Convert a dict-like object to struct; or</li>
<li>Convert an array of dict-like objects to a struct array.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>DictLike | ArrayLike[DictLike]</code></dt>
<dd>object to convert.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F", "A", "K"} | None</code>, default=<code>None</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style);
* "A" (any) means "F" if a is Fortran contiguous, "C" otherwise;
* "K" (keep) preserve input order;
* <code>None</code> preserve input order if possible, "C" otherwise.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool | None</code>, default=<code>None</code></dt>
<dd>Whether to copy the underlying data.
* <code>True</code> : the object is copied;
* <code>None</code> : the the object is copied only if needed;
* <code>False</code>: raises a <code>ValueError</code> if a copy cannot be avoided.</dd>
<dt><strong><code>owndata</code></strong> :&ensp;<code>bool</code>, default=<code>None</code></dt>
<dd>If True, ensures that the returned Struct owns its data.
This may trigger an additional copy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code></dt>
<dd>Converted structure.</dd>
</dl></div>
</dd>
<dt id="__wrapper__.Struct.from_cell"><code class="name flex">
<span>def <span class="ident">from_cell</span></span>(<span>other, **kwargs) ‑> <a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></span>
</code></dt>
<dd>
<div class="desc"><p>See <code>from_any</code>.</p></div>
</dd>
<dt id="__wrapper__.Struct.from_shape"><code class="name flex">
<span>def <span class="ident">from_shape</span></span>(<span>shape=(), **kwargs) ‑> <a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build a struct array of a given size.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>list[int]</code></dt>
<dd>Input shape.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>{"C", "F"} | None</code>, default=<code>"C"</code></dt>
<dd>Memory layout.
* "C" row-major (C-style);
* "F" column-major (Fortran-style).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>struct</code></strong> :&ensp;<code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code></dt>
<dd>New struct array.</dd>
</dl></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="__wrapper__.Struct.as_struct"><code class="name">prop <span class="ident">as_struct</span> : <a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_struct(self) -&gt; &#34;Struct&#34;:
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="__wrapper__.Struct.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self, keys=None) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self, keys=None) -&gt; dict:
    &#34;&#34;&#34;
    Convert the object into a plain dict.

    * If a struct, return the underlying dict (no copy, is a view)
    * If a struct array, return a dict of Cell (copy, not a view)
    &#34;&#34;&#34;
    self._ensure_defaults_are_set(keys)

    # NOTE
    #   The `keys` argument is only used in `__getattr__` to avoid
    #   building the entire dictionary, when the content of a single
    #   key is eventually used.

    # scalar struct -&gt; return the underlying dictionary
    arr = np.ndarray.view(self, np.ndarray)

    if arr.ndim == 0:
        asdict = arr.item()
        if keys is not None:
            asdict = {key: asdict[key] for key in keys}
        return asdict

    # otherwise     -&gt; reverse array/dict order -&gt; dict of cells of values

    if keys is None:
        keys = self._allkeys()
    elif isinstance(keys, str):
        keys = [keys]

    opt = dict(flags=[&#39;refs_ok&#39;, &#39;zerosize_ok&#39;], op_flags=[&#39;readwrite&#39;])
    asdict = {key: [] for key in keys}
    with np.nditer(arr, **opt) as iter:
        for elem in iter:
            item = elem.item()
            for key in keys:
                asdict[key].append(item[key])
    for key in keys:
        asdict[key] = Cell.from_any(asdict[key])
    raise ValueError(keys)
    return asdict</code></pre>
</details>
<div class="desc"><p>Convert the object into a plain dict.</p>
<ul>
<li>If a struct, return the underlying dict (no copy, is a view)</li>
<li>If a struct array, return a dict of Cell (copy, not a view)</li>
</ul></div>
</dd>
</dl>
</dd>
<dt id="__wrapper__.WrappedArray"><code class="flex name class">
<span>class <span class="ident">WrappedArray</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedArray(np.ndarray, AnyWrappedArray):
    &#34;&#34;&#34;
    Base class for &#34;arrays of things&#34; (Array, Cell, Struct.)
    &#34;&#34;&#34;

    # Value used to initalize empty arrays
    @classmethod
    def _DEFAULT(cls, shape: list = ()):
        raise NotImplementedError

    def __str__(self):
        fmt = {&#34;all&#34;: str}  # use str instead of repr for items
        return np.array2string(self, separator=&#34;, &#34;, formatter=fmt)

    def __repr__(self):
        # close to np.array_repr, but hides dtype.
        pre = type(self).__name__ + &#34;(&#34;
        suf = &#34;)&#34;
        return (
            pre +
            np.array2string(self, prefix=pre, suffix=suf, separator=&#34;, &#34;) +
            suf
        )

    def __bool__(self):
        # NumPy arrays do not lower to True/False in a boolean context.
        # We do lower our matlab equivalent using all()
        return np.ndarray.view(np.all(self), np.ndarray).item()

    def __iter__(self):
        # FIXME:
        #   ndarray.__iter__ seems to call __getattr__, which leads
        #   to infinite resizing.
        #   This overload seems to fix it, but may not be computationally
        #   optimal.
        for i in range(len(self)):
            yield self[i]

    def __getitem__(self, index):
        &#34;&#34;&#34;Resize array if needed, then fallback to np.ndarray indexing.&#34;&#34;&#34;
        try:
            return super().__getitem__(index)
        except IndexError:
            # We return a delayed version of the current type, with the
            # same shape as the requested view. Its elements will only
            # be inserted into the original object (self) is the view
            # is properly finalized by an eventual call to __setitem__
            # or __setattr__.
            return self._return_delayed(index)

    def __setitem__(self, index, value):
        &#34;&#34;&#34;Resize array if needed, then fallback to np.ndarray indexing.&#34;&#34;&#34;
        value = MatlabType.from_any(value)
        try:
            return super().__setitem__(index, value)
        except (IndexError, ValueError):
            self._resize_for_index(index)
            return super().__setitem__(index, value)

    def __delitem__(self, index):
        if isinstance(index, tuple):
            raise TypeError(
                &#34;Multidimensional indices are not supported in `del`.&#34;
            )

        # --- list: delete sequentially, from tail to head -------------
        if hasattr(index, &#34;__iter__&#34;):
            index = (len(self) + i if i &lt; 0 else i for i in index)
            index = sorted(index, reverse=True)
            for i in index:
                del self[i]

        # --- slice: skip the entire slice, if possible ----------------
        elif isinstance(index, slice):
            start, stop, step = index.start, index.stop, index.step

            # --- let&#39;s make the slice parameters a bit more useful ---
            step = step or 1
            # compute true start
            if start is None:
                if step &lt; 0:
                    start = len(self) - 1
                else:
                    start = 0
            if start &lt; 0:
                start = len(self) + start
            # compute stop in terms of &#34;positive indices&#34;
            # (where -1 really means -1, and not n-1)
            if stop is not None:
                if stop &lt; 0:
                    stop = len(self) + stop
            else:
                stop = len(self) if step &gt; 0 else -1
            stop = min(stop, len(self)) if step &gt; 0 else max(stop, -1)
            # align stop with steps
            stop = start + int(np.ceil(abs(stop - start) / abs(step))) * step
            # compute true inclusive stop
            stop_inclusive = stop - step
            # ensure step is positive
            if step &lt; 0:
                start, stop_inclusive, step = stop_inclusive, start, abs(step)

            # --- if non consecutive, fallback to sequential ---
            if step != 1:
                index = range(start, stop+1, step)
                del self[index]

            # --- otherwise, skip the entire slice ---
            else:
                nb_del = 1 + stop_inclusive - start
                new_shape = list(np.shape(self))
                new_shape[0] -= nb_del
                self[start:-nb_del] = self[stop_inclusive:]
                np.ndarray.resize(self, new_shape, refcheck=False)

        # --- int: skip a single element -------------------------------
        else:
            index = int(index)
            if index &lt; 0:
                index = len(self) + index
            new_shape = list(np.shape(self))
            new_shape[0] -= 1
            self[index:-1] = self[index+1:]
            np.ndarray.resize(self, new_shape, refcheck=False)

    def _resize_for_index(self, index, set_default=True):
        &#34;&#34;&#34;
        Resize the array so that the (multidimensional) index is not OOB.

        We only support a restricted number of cases:
            * Index should only contain integers and slices
              (no smart indexing, no new axis, no ellipsis)
            * Only integer indices are used to compute the new size.
              This is to be consistent with numpy, where slice-indexing never
              raises IndexError (but instead returns the overlap between
              the array and the slice -- eventually empty).

        Other cases could be handled but require much more complicated logic.
        &#34;&#34;&#34;
        input_shape = self.shape
        if not isinstance(index, tuple):
            index = (index,)
        index, new_index = list(index), []
        shape, new_shape = list(np.shape(self)), []
        axis = -1
        while index:
            next_index = index.pop(0)
            if shape:
                next_shape = shape.pop(0)
            else:
                next_shape = 1
            axis += 1
            if isinstance(next_index, int):
                if next_index &lt; 0:
                    next_index = next_shape + next_index
                if next_index &gt;= next_shape:
                    next_shape = next_index + 1
            elif isinstance(next_index, slice):
                # FIXME: this is not exactly right when abs(step) != 1
                step = next_index.step or 1
                start = next_index.start
                stop = next_index.stop
                start = next_shape + start if start &lt; 0 else start
                stop = next_shape + stop if stop &lt; 0 else stop
                if step &lt; 0:
                    max_index = start
                else:
                    max_index = stop
                if max_index is None:
                    max_index = next_shape
                if max_index &gt; next_shape:
                    next_shape = max_index
            elif not isinstance(next_index, slice):
                raise TypeError(
                    &#34;Can only automatically resize cell if simple &#34;
                    &#34;indexing (int, slice) is used.&#34;
                )
            new_index.append(next_index)
            new_shape.append(next_shape)
        new_shape = new_shape + shape
        if not input_shape:
            # We risk erasing the original scalar whn setting the
            # defaults, so we save it and reinsert it at the end.
            scalar = np.ndarray.view(self, np.ndarray).item()
        np.ndarray.resize(self, new_shape, refcheck=False)
        if set_default:
            arr = np.ndarray.view(self, np.ndarray)
            view_index = tuple(slice(x, None) for x in input_shape)
            view_shape = arr[view_index].shape
            new_data = self._DEFAULT(view_shape)
            arr[view_index] = new_data
            if not input_shape:
                # Insert back scalar in the first position.
                scalar_index = (0,) * arr.ndim
                arr[scalar_index] = scalar

    def _return_delayed(self, index):
        if not isinstance(index, tuple):
            index = (index,)

        #   Resize as if we were already performing a valid __setitem__.
        #   This helps us guess the shape of the view.
        #   Also, we&#39;ll hopefully be able to use the allocated space
        #   later if the caller did not mess up their syntax, so there&#39;s
        #   not much wasted performance.
        shape = self.shape
        self._resize_for_index(index, set_default=False)

        #   Ensure that the indexed view is an array, not a single item.
        index_for_view = index
        if ... not in index_for_view:
            index_for_view = index_for_view + (...,)

        sub_shape = np.ndarray.view(self, np.ndarray)[index_for_view].shape

        #   Now, undo resize so that if the caller&#39;s syntax is wrong and
        #   an exception is raised (and caught), it&#39;s as if nothing ever
        #   happened.
        np.ndarray.resize(self, shape, refcheck=False)

        #   If self is wrapped in a DelayedCell/DelayedStruct,
        #   reference wrapper instead of self.
        parent = getattr(self, &#34;_delayed_wrapper&#34;, self)

        if isinstance(self, Cell):
            if sub_shape == ():
                return AnyDelayedArray(parent, index)
            else:
                return DelayedCell(sub_shape, parent, index)

        elif isinstance(self, Struct):
            return DelayedStruct(sub_shape, parent, index)

        else:
            #   In numeric arrays, only seeting OOB items is allowed.
            #   Getting OOB items should raise an error, which this
            #   call to the ndarray accessor will do.
            return super().__getitem__(index)</code></pre>
</details>
<div class="desc"><p>Base class for "arrays of things" (Array, Cell, Struct.)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>numpy.ndarray</li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></li>
<li><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></li>
<li><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.AnyWrappedArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.WrappedDelayedArray"><code class="flex name class">
<span>class <span class="ident">WrappedDelayedArray</span></span>
<span>(</span><span>future, parent, *index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedDelayedArray(AnyDelayedArray):

    def __init__(self, future, parent, *index):
        super().__init__(parent, *index)
        self._future = future

    def __call__(self, *index):
        return self._future.__call__(*index)

    def __getitem__(self, index):
        return self._future.__getitem__(index)

    def __getattr__(self, key):
        return self._future.__getattr__(key)

    def __setitem__(self, index, value):
        self._future.__setitem__(index, value)
        self._finalize()

    def __setattr__(self, key, value):
        if key in type(self)._ATTRIBUTES:
            return super().__setattr__(key, value)
        self._future.__setattr__(key, value)
        self._finalize()</code></pre>
</details>
<div class="desc"><p>This is an object that we return when we don't know how an indexed
element will be used yet.</p>
<p>It decides whether it is a Struct, Cell or Array based on the
type of indexing that is used.</p>
<p>In Matlab:
* <code>a(x,y)
= num</code>
indicates that <code>a</code> is a numeric array;
* <code>a(x,y)
= cell</code> indicates that <code>a</code> is a cell array;
* <code>a{x,y}
= any</code>
indicates that <code>a</code> is a cell array;
* <code>a(x,y).f = any</code>
indicates that <code>a</code> is a struct array;
* <code>a.f
= any</code>
indicates that <code>a</code> is a struct.</p>
<p>These indexing operations can be chained, so in
<code>a(x).b.c{y}.d(z) = 2</code>:
* <code>a</code>
is a struct array;
* <code>b</code>
is a struct;
* <code>c</code>
is a cell;
* <code>c{y}</code> is a struct
* <code>d</code>
is a numeric array.</p>
<p>In Python, there is only one type of indexing (<code>[]</code>). This is a problem as
we cannot differentiate <code>a{x}.b = y</code> &ndash; where <code>a</code> is a cell that contains
a struct &ndash; from <code>a(x).b = y</code> &mdash; where <code>a</code> is a struct array.</p>
<p>One solution may be to abuse the "call" operator <code>()</code>, so that it returns a
cell. This would work in some situations (<code>a[x].b = y</code> is a struct array,
whereas <code>a(x).b = y</code> is a cell of struct). However, the statement
<code>a(x) = y</code> (which would correspond to matlab's <code>a{x} = y</code>) is not valid
python syntax. Furthermore, it would induce a new problem, as cells could
not be differentiated from function handles, in some cases.</p>
<p>Instead, the use of brackets automatically transforms the object into
either:
* a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code> (in all "get" cases, and in the "set" context <code>a[x] = y</code>,
when <code>y</code> is either a <code>dict</code> or a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>); or
* a <code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code> (in the "set" context <code>a[x] = y</code>, when <code>y</code> is neither a
<code>dict</code> nor a <code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code>).</p>
<p>Alternatively, if the user wishes to specify which type the object should
take, we implement the properties <code>as_cell</code>, <code>as_struct</code> and <code>as_num</code>.</p>
<p>Therefore:
* <code>a[x,y]
= num</code>
: <code>a</code> is a numeric array;
* <code>a[x,y]
= struct</code> : <code>a</code> is a numeric array;
* <code>a[x,y].f
= any</code>
: <code>a</code> is a struct array;
* <code>a(x,y).f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.f
= any</code>
: <code>a</code> is a struct.</p>
<p>And explictly:
* <code>a.as_cell[x,y]
= any</code>
: <code>a</code> is a cell array;
* <code>a.as_struct[x,y].f = any</code>
: <code>a</code> is a struct array;
* <code>a.as_cell[x,y].f
= any</code>
: <code>a</code> is a cell array containing a struct;
* <code>a.as_num[x,y]
= num</code>
: <code>a</code> is a numeric array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>ndarray | dict</code></dt>
<dd>Reference to the object that will eventually contain
this element.
* If the containing array is a Cell, <code>parent</code> should be a
<code>ndarray</code> view of that cell, and <code>index</code> should be a
[tuple of] int.
* If the containing array is a Struct, <code>parent</code> should be a
<code>dict</code>, and <code>index</code> should be a string.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>str | [tuple of] int</code></dt>
<dd>Index into the parent where this element will be inserted.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.DelayedArray" href="#__wrapper__.DelayedArray">DelayedArray</a></li>
<li><a title="__wrapper__.DelayedCell" href="#__wrapper__.DelayedCell">DelayedCell</a></li>
<li><a title="__wrapper__.DelayedStruct" href="#__wrapper__.DelayedStruct">DelayedStruct</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.AnyDelayedArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="__wrapper__.WrappedSparseArray"><code class="flex name class">
<span>class <span class="ident">WrappedSparseArray</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WrappedSparseArray(sparse.sparray, AnyWrappedArray):
    &#34;&#34;&#34;Base class for sparse arrays.&#34;&#34;&#34;

    def to_dense(self) -&gt; &#34;Array&#34;:
        return Array.from_any(self.todense())</code></pre>
</details>
<div class="desc"><p>Base class for sparse arrays.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scipy.sparse._base.sparray</li>
<li><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></li>
<li><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></li>
<li><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="__wrapper__.WrappedSparseArray.to_dense"><code class="name flex">
<span>def <span class="ident">to_dense</span></span>(<span>self) ‑> <a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dense(self) -&gt; &#34;Array&#34;:
    return Array.from_any(self.todense())</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></b></code>:
<ul class="hlist">
<li><code><a title="__wrapper__.AnyWrappedArray.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="__wrapper__.AnyDelayedArray" href="#__wrapper__.AnyDelayedArray">AnyDelayedArray</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.AnyDelayedArray.as_cell" href="#__wrapper__.AnyDelayedArray.as_cell">as_cell</a></code></li>
<li><code><a title="__wrapper__.AnyDelayedArray.as_num" href="#__wrapper__.AnyDelayedArray.as_num">as_num</a></code></li>
<li><code><a title="__wrapper__.AnyDelayedArray.as_obj" href="#__wrapper__.AnyDelayedArray.as_obj">as_obj</a></code></li>
<li><code><a title="__wrapper__.AnyDelayedArray.as_struct" href="#__wrapper__.AnyDelayedArray.as_struct">as_struct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.AnyMatlabArray" href="#__wrapper__.AnyMatlabArray">AnyMatlabArray</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.AnyMatlabArray.as_cell" href="#__wrapper__.AnyMatlabArray.as_cell">as_cell</a></code></li>
<li><code><a title="__wrapper__.AnyMatlabArray.as_num" href="#__wrapper__.AnyMatlabArray.as_num">as_num</a></code></li>
<li><code><a title="__wrapper__.AnyMatlabArray.as_struct" href="#__wrapper__.AnyMatlabArray.as_struct">as_struct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.AnyWrappedArray" href="#__wrapper__.AnyWrappedArray">AnyWrappedArray</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.Array" href="#__wrapper__.Array">Array</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.Array.as_num" href="#__wrapper__.Array.as_num">as_num</a></code></li>
<li><code><a title="__wrapper__.Array.from_any" href="#__wrapper__.Array.from_any">from_any</a></code></li>
<li><code><a title="__wrapper__.Array.from_cell" href="#__wrapper__.Array.from_cell">from_cell</a></code></li>
<li><code><a title="__wrapper__.Array.from_shape" href="#__wrapper__.Array.from_shape">from_shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.Cell" href="#__wrapper__.Cell">Cell</a></code></h4>
<ul class="two-column">
<li><code><a title="__wrapper__.Cell.as_cell" href="#__wrapper__.Cell.as_cell">as_cell</a></code></li>
<li><code><a title="__wrapper__.Cell.deepcat" href="#__wrapper__.Cell.deepcat">deepcat</a></code></li>
<li><code><a title="__wrapper__.Cell.from_any" href="#__wrapper__.Cell.from_any">from_any</a></code></li>
<li><code><a title="__wrapper__.Cell.from_array" href="#__wrapper__.Cell.from_array">from_array</a></code></li>
<li><code><a title="__wrapper__.Cell.from_num" href="#__wrapper__.Cell.from_num">from_num</a></code></li>
<li><code><a title="__wrapper__.Cell.from_shape" href="#__wrapper__.Cell.from_shape">from_shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.DelayedArray" href="#__wrapper__.DelayedArray">DelayedArray</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.DelayedCell" href="#__wrapper__.DelayedCell">DelayedCell</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.DelayedStruct" href="#__wrapper__.DelayedStruct">DelayedStruct</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.IndexOrKeyOrAttributeError" href="#__wrapper__.IndexOrKeyOrAttributeError">IndexOrKeyOrAttributeError</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.MatlabClass" href="#__wrapper__.MatlabClass">MatlabClass</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.MatlabFunction" href="#__wrapper__.MatlabFunction">MatlabFunction</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.MatlabType" href="#__wrapper__.MatlabType">MatlabType</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.MatlabType.from_any" href="#__wrapper__.MatlabType.from_any">from_any</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.Runtime" href="#__wrapper__.Runtime">Runtime</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.Runtime.call" href="#__wrapper__.Runtime.call">call</a></code></li>
<li><code><a title="__wrapper__.Runtime.instance" href="#__wrapper__.Runtime.instance">instance</a></code></li>
<li><code><a title="__wrapper__.Runtime.verbose" href="#__wrapper__.Runtime.verbose">verbose</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.SparseArray" href="#__wrapper__.SparseArray">SparseArray</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.SparseArray.from_any" href="#__wrapper__.SparseArray.from_any">from_any</a></code></li>
<li><code><a title="__wrapper__.SparseArray.from_coo" href="#__wrapper__.SparseArray.from_coo">from_coo</a></code></li>
<li><code><a title="__wrapper__.SparseArray.from_shape" href="#__wrapper__.SparseArray.from_shape">from_shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.Struct" href="#__wrapper__.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.Struct.as_dict" href="#__wrapper__.Struct.as_dict">as_dict</a></code></li>
<li><code><a title="__wrapper__.Struct.as_struct" href="#__wrapper__.Struct.as_struct">as_struct</a></code></li>
<li><code><a title="__wrapper__.Struct.from_any" href="#__wrapper__.Struct.from_any">from_any</a></code></li>
<li><code><a title="__wrapper__.Struct.from_cell" href="#__wrapper__.Struct.from_cell">from_cell</a></code></li>
<li><code><a title="__wrapper__.Struct.from_shape" href="#__wrapper__.Struct.from_shape">from_shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="__wrapper__.WrappedArray" href="#__wrapper__.WrappedArray">WrappedArray</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.WrappedDelayedArray" href="#__wrapper__.WrappedDelayedArray">WrappedDelayedArray</a></code></h4>
</li>
<li>
<h4><code><a title="__wrapper__.WrappedSparseArray" href="#__wrapper__.WrappedSparseArray">WrappedSparseArray</a></code></h4>
<ul class="">
<li><code><a title="__wrapper__.WrappedSparseArray.to_dense" href="#__wrapper__.WrappedSparseArray.to_dense">to_dense</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
