<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>spm.spm_fmri_spm_ui API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spm.spm_fmri_spm_ui</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spm.spm_fmri_spm_ui.spm_fmri_spm_ui"><code class="name flex">
<span>def <span class="ident">spm_fmri_spm_ui</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spm_fmri_spm_ui(*args, **kwargs):
    &#34;&#34;&#34;
      Setting up the general linear model for fMRI time-series  
        FORMAT [SPM] = spm_fmri_spm_ui(SPM)  
         
        creates SPM with the following fields  
         
              xY: [1x1 struct] - data structure  
           nscan: [double]     - vector of scans per session  
             xBF: [1x1 struct] - Basis function structure   (see spm_fMRI_design)  
            Sess: [1x1 struct] - Session structure          (see spm_fMRI_design)  
              xX: [1x1 struct] - Design matrix structure    (see spm_fMRI_design)  
             xGX: [1x1 struct] - Global variate structure  
             xVi: [1x1 struct] - Non-sphericity structure  
              xM: [1x1 struct] - Masking structure  
           xsDes: [1x1 struct] - Design description structure  
         
         
            SPM.xY  
                    P: [n x ? char]       - filenames  
                   VY: [n x 1 struct]     - filehandles  
                   RT: Repeat time  
         
           SPM.xGX  
         
              iGXcalc: {&#39;none&#39;|&#39;Scaling&#39;} - Global normalization option  
              sGXcalc: &#39;mean voxel value&#39; - Calculation method  
               sGMsca: &#39;session specific&#39; - Grand mean scaling  
                   rg: [n x 1 double]     - Global estimate  
                   GM: 100                - Grand mean  
                  gSF: [n x 1 double]     - Global scaling factor  
         
           SPM.xVi  
                   Vi: {[n x n sparse]..} - covariance components  
                 form: {&#39;none&#39;|&#39;AR(1)&#39;}   - form of non-sphericity  
         
            SPM.xM  
                    T: [n x 1 double]     - Masking index  
                   TH: [n x 1 double]     - Threshold  
                    I: 0  
                   VM:                    - Mask filehandles  
                   xs: [1x1 struct]       - cellstr description  
         
       __________________________________________________________________________  
         
        spm_fmri_spm_ui configures the design matrix, data specification and  
        filtering that specify the ensuing statistical analysis. These arguments  
        are passed to spm_spm that then performs the actual parameter estimation.  
         
        The design matrix defines the experimental design and the nature of  
        hypothesis testing to be implemented.  The design matrix has one row for  
        each scan and one column for each effect or explanatory variable (e.g.  
        regressor or stimulus function).  The parameters are estimated in a least  
        squares sense using the general linear model.  Specific profiles within  
        these parameters are tested using a linear compound or contrast with the  
        T or F statistic.  The resulting statistical map constitutes an SPM.  The  
        SPM{T}/{F} is then characterized in terms of focal or regional  
        differences by assuming that (under the null hypothesis) the components  
        of the SPM (i.e. residual fields) behave as smooth stationary Gaussian  
        fields.  
         
        spm_fmri_spm_ui allows you to (i) specify a statistical model in terms of  
        a design matrix, (ii) associate some data with a pre-specified design [or  
        (iii) specify both the data and design] and then proceed to estimate the  
        parameters of the model.  
        Inferences can be made about the ensuing parameter estimates (at a first  
        or fixed-effect level) in the results section, or they can be re-entered  
        into a second (random-effect) level analysis by treating the session or  
        subject-specific [contrasts of] parameter estimates as new summary data.  
        Inferences at any level are obtained by specifying appropriate T or F  
        contrasts in the results section to produce SPMs and tables of p values  
        and statistics.  
         
        spm_fmri_spm calls spm_fMRI_design which allows you to configure a design  
        matrix in terms of events or epochs.  
         
        spm_fMRI_design allows you to build design matrices with separable  
        session-specific partitions.  Each partition may be the same (in which  
        case it is only necessary to specify it once) or different.  Responses  
        can be either event- or epoch related, The only distinction is the  
        duration of the underlying input or stimulus function. Mathematically  
        they are both modelled by convolving a series of delta (stick) or box  
        functions (u), indicating the onset of an event or epoch with a set of  
        basis functions.  These basis functions model the hemodynamic  
        convolution, applied by the brain, to the inputs.  This convolution can  
        be first-order or a generalized convolution modelled to second order (if  
        you specify the Volterra option). [The same inputs are used by the  
        hemodynamic model or or dynamic causal models which model the convolution  
        explicitly in terms of hidden state variables (see spm_hdm_ui and  
        spm_dcm_ui).]  
        Basis functions can be used to plot estimated responses to single events  
        once the parameters (i.e. basis function coefficients) have been  
        estimated.  The importance of basis functions is that they provide a  
        graceful transition between simple fixed response models (like the  
        box-car) and finite impulse response (FIR) models, where there is one  
        basis function for each scan following an event or epoch onset.  The nice  
        thing about basis functions, compared to FIR models, is that data  
        sampling and stimulus presentation does not have to be synchronized  
        thereby allowing a uniform and unbiased sampling of peri-stimulus time.  
         
        Event-related designs may be stochastic or deterministic.  Stochastic  
        designs involve one of a number of trial-types occurring with a specified  
        probably at successive intervals in time.  These probabilities can be  
        fixed (stationary designs) or time-dependent (modulated or non-stationary  
        designs).  The most efficient designs obtain when the probabilities of  
        every trial type are equal.  
        A critical issue in stochastic designs is whether to include null events  
        If you wish to estimate the evoke response to a specific event type (as  
        opposed to differential responses) then a null event must be included  
        (even if it is not modelled explicitly).  
         
        The choice of basis functions depends upon the nature of the inference  
        sought.  One important consideration is whether you want to make  
        inferences about compounds of parameters (i.e.  contrasts).  This is the  
        case if (i) you wish to use a SPM{T} to look separately at activations  
        and deactivations or (ii) you with to proceed to a second (random-effect)  
        level of analysis.  If this is the case then (for event-related studies)  
        use a canonical hemodynamic response function (HRF) and derivatives with  
        respect to latency (and dispersion).  Unlike other bases, contrasts of  
        these effects have a physical interpretation and represent a parsimonious  
        way of characterising event-related responses.  Bases such as a Fourier  
        set require the SPM{F} for inference.  
         
        See spm_fMRI_design for more details about how designs are specified.  
         
        Serial correlations in fast fMRI time-series are dealt with as described  
        in spm_spm.  At this stage you need to specify the filtering that will be  
        applied to the data (and design matrix) to give a generalized least  
        squares (GLS) estimate of the parameters required.  This filtering is  
        important to ensure that the GLS estimate is efficient and that the error  
        variance is estimated in an unbiased way.  
         
        The serial correlations will be estimated with a ReML (restricted maximum  
        likelihood) algorithm using an autoregressive AR(1) model during  
        parameter estimation.  This estimate assumes the same correlation  
        structure for each voxel, within each session.  The ReML estimates are  
        then used to correct for non-sphericity during inference by adjusting the  
        statistics and degrees of freedom appropriately.  The discrepancy between  
        estimated and actual intrinsic (i.e. prior to filtering) correlations are  
        greatest at low frequencies.  Therefore specification of the high-pass  
        filter is particularly important.  
         
        High-pass filtering is implemented at the level of the filtering matrix K  
        (as opposed to entering as confounds in the design matrix).  The default  
        cut-off period is 128 seconds. Use &#39;explore design&#39; to ensure this  
        cut-off is not removing too much experimental variance.  
        Note that high-pass filtering uses a residual forming matrix (i.e. it is  
        not a convolution) and is simply to a way to remove confounds without  
        estimating their parameters explicitly.  The constant term is also  
        incorporated into this filter matrix.  
         
       --------------------------------------------------------------------------  
        Refs:  
         
        Friston KJ, Holmes A, Poline J-B, Grasby PJ, Williams SCR, Frackowiak  
        RSJ &amp; Turner R (1995) Analysis of fMRI time-series revisited. NeuroImage  
        2:45-53  
         
        Worsley KJ and Friston KJ (1995) Analysis of fMRI time-series revisited -  
        again. NeuroImage 2:178-181  
         
        Friston KJ, Frith CD, Frackowiak RSJ, &amp; Turner R (1995) Characterising  
        dynamic brain responses with fMRI: A multivariate approach NeuroImage -  
        2:166-172  
         
        Frith CD, Turner R &amp; Frackowiak RSJ (1995) Characterising evoked  
        hemodynamics with fMRI Friston KJ, NeuroImage 2:157-165  
         
        Josephs O, Turner R and Friston KJ (1997) Event-related fMRI, Hum. Brain  
        Map. 5:243-248  
         
       __________________________________________________________________________  
      

    [Matlab code]( https://github.com/spm/spm/blob/main/spm_fmri_spm_ui.m )

    Copyright (C) 1995-2025 Functional Imaging Laboratory, Department of Imaging Neuroscience, UCL
    &#34;&#34;&#34;
    return Runtime.call(&#34;spm_fmri_spm_ui&#34;, *args, **kwargs)</code></pre>
</details>
<div class="desc"><p>Setting up the general linear model for fMRI time-series<br>
FORMAT [SPM] = spm_fmri_spm_ui(SPM)
</p>
<pre><code>creates SPM with the following fields

      xY: [1x1 struct] - data structure  
   nscan: [double]     - vector of scans per session  
     xBF: [1x1 struct] - Basis function structure   (see spm_fMRI_design)  
    Sess: [1x1 struct] - Session structure          (see spm_fMRI_design)  
      xX: [1x1 struct] - Design matrix structure    (see spm_fMRI_design)  
     xGX: [1x1 struct] - Global variate structure  
     xVi: [1x1 struct] - Non-sphericity structure  
      xM: [1x1 struct] - Masking structure  
   xsDes: [1x1 struct] - Design description structure


    SPM.xY  
            P: [n x ? char]       - filenames  
           VY: [n x 1 struct]     - filehandles  
           RT: Repeat time

   SPM.xGX

      iGXcalc: {'none'|'Scaling'} - Global normalization option  
      sGXcalc: 'mean voxel value' - Calculation method  
       sGMsca: 'session specific' - Grand mean scaling  
           rg: [n x 1 double]     - Global estimate  
           GM: 100                - Grand mean  
          gSF: [n x 1 double]     - Global scaling factor

   SPM.xVi  
           Vi: {[n x n sparse]..} - covariance components  
         form: {'none'|'AR(1)'}   - form of non-sphericity

    SPM.xM  
            T: [n x 1 double]     - Masking index  
           TH: [n x 1 double]     - Threshold  
            I: 0  
           VM:                    - Mask filehandles  
           xs: [1x1 struct]       - cellstr description
</code></pre>
<hr>
<pre><code>spm_fmri_spm_ui configures the design matrix, data specification and  
filtering that specify the ensuing statistical analysis. These arguments  
are passed to spm_spm that then performs the actual parameter estimation.

The design matrix defines the experimental design and the nature of  
hypothesis testing to be implemented.  The design matrix has one row for  
each scan and one column for each effect or explanatory variable (e.g.  
regressor or stimulus function).  The parameters are estimated in a least  
squares sense using the general linear model.  Specific profiles within  
these parameters are tested using a linear compound or contrast with the  
T or F statistic.  The resulting statistical map constitutes an SPM.  The  
SPM{T}/{F} is then characterized in terms of focal or regional  
differences by assuming that (under the null hypothesis) the components  
of the SPM (i.e. residual fields) behave as smooth stationary Gaussian  
fields.

spm_fmri_spm_ui allows you to (i) specify a statistical model in terms of  
a design matrix, (ii) associate some data with a pre-specified design [or  
(iii) specify both the data and design] and then proceed to estimate the  
parameters of the model.  
Inferences can be made about the ensuing parameter estimates (at a first  
or fixed-effect level) in the results section, or they can be re-entered  
into a second (random-effect) level analysis by treating the session or  
subject-specific [contrasts of] parameter estimates as new summary data.  
Inferences at any level are obtained by specifying appropriate T or F  
contrasts in the results section to produce SPMs and tables of p values  
and statistics.

spm_fmri_spm calls spm_fMRI_design which allows you to configure a design  
matrix in terms of events or epochs.

spm_fMRI_design allows you to build design matrices with separable  
session-specific partitions.  Each partition may be the same (in which  
case it is only necessary to specify it once) or different.  Responses  
can be either event- or epoch related, The only distinction is the  
duration of the underlying input or stimulus function. Mathematically  
they are both modelled by convolving a series of delta (stick) or box  
functions (u), indicating the onset of an event or epoch with a set of  
basis functions.  These basis functions model the hemodynamic  
convolution, applied by the brain, to the inputs.  This convolution can  
be first-order or a generalized convolution modelled to second order (if  
you specify the Volterra option). [The same inputs are used by the  
hemodynamic model or or dynamic causal models which model the convolution  
explicitly in terms of hidden state variables (see spm_hdm_ui and  
spm_dcm_ui).]  
Basis functions can be used to plot estimated responses to single events  
once the parameters (i.e. basis function coefficients) have been  
estimated.  The importance of basis functions is that they provide a  
graceful transition between simple fixed response models (like the  
box-car) and finite impulse response (FIR) models, where there is one  
basis function for each scan following an event or epoch onset.  The nice  
thing about basis functions, compared to FIR models, is that data  
sampling and stimulus presentation does not have to be synchronized  
thereby allowing a uniform and unbiased sampling of peri-stimulus time.

Event-related designs may be stochastic or deterministic.  Stochastic  
designs involve one of a number of trial-types occurring with a specified  
probably at successive intervals in time.  These probabilities can be  
fixed (stationary designs) or time-dependent (modulated or non-stationary  
designs).  The most efficient designs obtain when the probabilities of  
every trial type are equal.  
A critical issue in stochastic designs is whether to include null events  
If you wish to estimate the evoke response to a specific event type (as  
opposed to differential responses) then a null event must be included  
(even if it is not modelled explicitly).

The choice of basis functions depends upon the nature of the inference  
sought.  One important consideration is whether you want to make  
inferences about compounds of parameters (i.e.  contrasts).  This is the  
case if (i) you wish to use a SPM{T} to look separately at activations  
and deactivations or (ii) you with to proceed to a second (random-effect)  
level of analysis.  If this is the case then (for event-related studies)  
use a canonical hemodynamic response function (HRF) and derivatives with  
respect to latency (and dispersion).  Unlike other bases, contrasts of  
these effects have a physical interpretation and represent a parsimonious  
way of characterising event-related responses.  Bases such as a Fourier  
set require the SPM{F} for inference.

See spm_fMRI_design for more details about how designs are specified.

Serial correlations in fast fMRI time-series are dealt with as described  
in spm_spm.  At this stage you need to specify the filtering that will be  
applied to the data (and design matrix) to give a generalized least  
squares (GLS) estimate of the parameters required.  This filtering is  
important to ensure that the GLS estimate is efficient and that the error  
variance is estimated in an unbiased way.

The serial correlations will be estimated with a ReML (restricted maximum  
likelihood) algorithm using an autoregressive AR(1) model during  
parameter estimation.  This estimate assumes the same correlation  
structure for each voxel, within each session.  The ReML estimates are  
then used to correct for non-sphericity during inference by adjusting the  
statistics and degrees of freedom appropriately.  The discrepancy between  
estimated and actual intrinsic (i.e. prior to filtering) correlations are  
greatest at low frequencies.  Therefore specification of the high-pass  
filter is particularly important.

High-pass filtering is implemented at the level of the filtering matrix K  
(as opposed to entering as confounds in the design matrix).  The default  
cut-off period is 128 seconds. Use 'explore design' to ensure this  
cut-off is not removing too much experimental variance.  
Note that high-pass filtering uses a residual forming matrix (i.e. it is  
not a convolution) and is simply to a way to remove confounds without  
estimating their parameters explicitly.  The constant term is also  
incorporated into this filter matrix.
</code></pre>
<hr>
<pre><code>Refs:

Friston KJ, Holmes A, Poline J-B, Grasby PJ, Williams SCR, Frackowiak  
RSJ &amp; Turner R (1995) Analysis of fMRI time-series revisited. NeuroImage  
2:45-53

Worsley KJ and Friston KJ (1995) Analysis of fMRI time-series revisited -  
again. NeuroImage 2:178-181

Friston KJ, Frith CD, Frackowiak RSJ, &amp; Turner R (1995) Characterising  
dynamic brain responses with fMRI: A multivariate approach NeuroImage -  
2:166-172

Frith CD, Turner R &amp; Frackowiak RSJ (1995) Characterising evoked  
hemodynamics with fMRI Friston KJ, NeuroImage 2:157-165

Josephs O, Turner R and Friston KJ (1997) Event-related fMRI, Hum. Brain  
Map. 5:243-248
</code></pre>
<hr>
<p><a href="https://github.com/spm/spm/blob/main/spm_fmri_spm_ui.m">Matlab code</a></p>
<p>Copyright (C) 1995-2025 Functional Imaging Laboratory, Department of Imaging Neuroscience, UCL</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spm" href="index.html">spm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spm.spm_fmri_spm_ui.spm_fmri_spm_ui" href="#spm.spm_fmri_spm_ui.spm_fmri_spm_ui">spm_fmri_spm_ui</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
