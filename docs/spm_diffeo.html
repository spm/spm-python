<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>spm.spm_diffeo API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spm.spm_diffeo</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spm.spm_diffeo.spm_diffeo"><code class="name flex">
<span>def <span class="ident">spm_diffeo</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spm_diffeo(*args, **kwargs):
    &#34;&#34;&#34;
      MEX function called for image registration stuff  
         
       __________________________________________________________________________  
         
        FORMAT u = spm_diffeo(&#39;vel2mom&#39;, v, param)  
        v     - velocity (flow) field n1*n2*n3*3.  
        param - 8 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6][7][8] Regularisation parameters  
                  - [4] Absolute displacements need to be penalised by a tiny  
                        amount.  The first element encodes the amount of  
                        penalty on these.  Ideally, absolute displacements  
                        should not be penalised, but it is often necessary  
                        for technical reasons.  
                  - [5] The `membrane energy&#39; of the deformation is penalised,  
                        usually by a relatively small amount. This penalises  
                        the sum of squares of the derivatives of the velocity  
                        field (ie the sum of squares of the elements of the  
                        Jacobian tensors).  
                  - [6] The `bending energy&#39; is penalised. This penalises the  
                        sum of squares of the 2nd derivatives of the parameters.  
                  - [7][8] Linear elasticity regularisation is also included.  
                           The first parameter (mu) is similar to that for  
                           linear elasticity, except it penalises the sum of  
                           squares of the Jacobian tensors after they have been  
                           made symmetric (by averaging with the transpose).  
                           This term essentially penalises length changes,  
                           without penalising rotations.  
                           The final term also relates to linear elasticity,  
                           and is the weight that denotes how much to penalise  
                           changes to the divergence of the velocities (lambda).  
                           This divergence is a measure of the rate of volumetric  
                           expansion or contraction.  
        u       - `momentum&#39; field n1*n2*n3*3.  
         
        Convert a velocity field to a momentum field by u = A*v, where  
        A is the large sparse matrix encoding some form of regularisation.  
        v and m are single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT v = spm_diffeo(&#39;mom2vel&#39;,g, param)  
        v     - the solution n1*n2*n3*3  
        g     - parameterisation of first derivatives  
        param - 10 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6][7][8] Regularisation settings (see vel2mom).  
                - [9] Number of Full Multigrid cycles.  
                - [10] Number of relaxation iterations per cycle.  
         
        Solve equations using a Full Multigrid method.  See Press et al  
        for more information.  
        v = inv(A)*g  
        g and v are both single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT v = spm_diffeo(&#39;fmg&#39;,H, g, param)  
        v     - the solution n1*n2*n3*3  
        H     - parameterisation of 2nd derivatives   
        g     - parameterisation of first derivatives  
        param - 10 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6][7][8] Regularisation settings (see vel2mom).  
                - [9] Number of Full Multigrid cycles.  
                - [10] Number of relaxation iterations per cycle.  
         
        Solve equations using a Full Multigrid method, but using Hessian of  
        the matching term.  See Press et al for more information.  
        v = inv(A+H)*g  
        H, g and v are all single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT v = spm_diffeo(&#39;cgs&#39;,H, g, param)  
        v     - the solution  
        H     - parameterisation of 2nd derivatives  
        g     - parameterisation of first derivatives  
        param - 10 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6][7][8] Regularisation settings (see vel2mom).  
                - [9] Tolerance.  Indicates required degree of accuracy.  
                - [10] Maximum number of iterations.  
         
        This is for solving a set of equations using a conjugate gradient  
        solver. This method is less efficient than the Full Multigrid, and  
        is included for illustrative purposes.  
        v = inv(A+H)*g  
        H, g and v are all single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT F = spm_diffeo(&#39;kernel&#39;,d,prm)  
        d   - image dimensions  
        prm - 8 parameters (settings).  
              These are described above (for &#39;vel2mom&#39;).  
        F   - The differential operator encoded as an image (or images).  
              Convolving a velocity field by this will give the momentum.  
         
              Note that a smaller (3D) kernel is obtained when the linear  
              elasticity settings are all zero.  If any of the linear  
              elasticity settings are non-zero, the resulting kernel is  
              represented by a 5D array. For the 3D form, the voxel sizes  
              need to be incorporated as an additional scaling of the kernel.  
              See the code in spm_shoot_greens.m for an illustration.  
         
       __________________________________________________________________________  
         
        FORMAT y3 = spm_diffeo(&#39;comp&#39;,y1,y2)  
        y1, y2 - deformation fields n1*n2*n3*3.  
        y3     - deformation field field n1*n2*n3*3.  
         
        Composition of two deformations y3 = y1(y2)  
        y1, y2 and y3 are single precision floating point.  
         
         
        FORMAT [y3,J3] = spm_diffeo(&#39;comp&#39;, y1, y2, J1, J2)  
        y1, y2 - deformation fields n1*n2*n3*3.  
        y3     - deformation field n1*n2*n3*3.  
        J1, J2 - Jacobian tensor fields n1*n2*n3*3*3.  
        J3     - Jacobian tensor field n1*n2*n3*3*3.  
         
        Composition of two deformations, with their Jacobian fields.  
        All fields are single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT iy = spm_diffeo(&#39;invdef&#39;,y,d,M1,M2);  
         
        iy - inverted deformation field of size d(1)*d(2)*d(3)*3.  
        y  - original deformation field.  
        M1 - An affine mapping from mm to voxels in the coordinate  
             system of the inverse deformation field.  
        M2 - An affine mapping from voxels to mm in the coordinate  
             system of the forward deformation field.  
         
        Inversion of a deformation field.  
         
        The field is assumed to consist of a piecewise affine transformations,  
        whereby each cube jointing 8 neighbouring voxels contains eight  
        tetrahedra.  The mapping within each tetrahedron is assumed to be  
        affine.  
         
         Reference:  
           J. Ashburner, J. Andersson and K. J. Friston (2000).  
           &#34;Image Registration using a Symmetric Prior - in Three-Dimensions&#34;.  
           Human Brain Mapping 9(4):212-225 (appendix).  
       __________________________________________________________________________  
         
        FORMAT [f,dfx,dfy,dfz] = spm_diffeo(&#39;bsplins&#39;, c, y,d)  
        c          - input image(s) of B-spline coefficients n1*n2*n3*n4  
                     - see &#39;bsplinc&#39;  
        y          - points to sample n1*n2*n3*3  
        d(1:3)     - degree of B-spline (from 0 to 7) along different dimensions  
                     - these must be same as used by &#39;bsplinc&#39;  
        d(4:6)     - 1/0 to indicate wrapping along the dimensions  
         
        f           - output image n1*n2*n3*n4  
        dfx,dfy,dfz - sampled first derivatives  
         
        c, f and y are single precision floating point.  
         
        This function takes B-spline basis coefficients from spm_bsplinc,  
        and re-convolves them with B-splines centred at the new sample points.  
          
        Note that nearest neighbour interpolation is used instead of 0th  
        degree B-splines, and the derivatives of trilinear interpolation are  
        returned instead of those of 1st degree B-splines.  The difference is  
        extremely subtle.  
         
        c, f and y are single precision floating point.  
          
         References:  
           M. Unser, A. Aldroubi and M. Eden.  
           &#34;B-Spline Signal Processing: Part I-Theory,&#34;  
           IEEE Transactions on Signal Processing 41(2):821-832 (1993).  
          
           M. Unser, A. Aldroubi and M. Eden.  
           &#34;B-Spline Signal Processing: Part II-Efficient Design and  
           Applications,&#34;  
           IEEE Transactions on Signal Processing 41(2):834-848 (1993).  
          
           M. Unser.  
           &#34;Splines: A Perfect Fit for Signal and Image Processing,&#34;  
           IEEE Signal Processing Magazine, 16(6):22-38 (1999)  
          
           P. Thevenaz and T. Blu and M. Unser.  
           &#34;Interpolation Revisited&#34;  
           IEEE Transactions on Medical Imaging 19(7):739-758 (2000).  
         
       __________________________________________________________________________  
         
        FORMAT c = spm_diffeo(&#39;bsplinc&#39;,f,d)  
          f - an image  
          d(1:3) - degree of B-spline (from 0 to 7) along different dimensions  
              d(4:6) - 1/0 to indicate wrapping along the dimensions  
          c - returned volume of B-spline coefficients  
         
        This function deconvolves B-splines from f, returning  
        coefficients, c.  These coefficients are then passed to &#39;bsplins&#39;  
        in order to sample the data using B-spline interpolation.  
         
       __________________________________________________________________________  
         
        FORMAT f2 = spm_diffeo(&#39;samp&#39;, f1, y)  
        f1 - input image(s) n1*n2*n3*n4  
        y  - points to sample n1*n2*n3*3  
        f2 - output image n1*n2*n3*n4  
         
        Sample a function according to a deformation using trilinear interp.  
        f2 = f1(y)  
        f1, f2 and y are single precision floating point.  
        Uses boundary condiditions that wrap around (circulant - identical to  
        the &#39;pullc&#39; option - but retained for backward compatibility).  
         
       __________________________________________________________________________  
         
        FORMAT f2 = spm_diffeo(&#39;pull&#39;, f1, y)  
        f1 - input image(s) n1*n2*n3*n4  
        y  - points to sample n1*n2*n3*3  
        f2 - output image n1*n2*n3*n4  
         
        Sample a function according to a deformation using trilinear interp.  
        f2 = f1(y)  
        f1, f2 and y are single precision floating point.  
        Values sampled outside the field of view of f1 are assigned a value  
        of NaN.  
         
       __________________________________________________________________________  
         
        FORMAT f2 = spm_diffeo(&#39;pullc&#39;, f1, y)  
        f1 - input image(s) n1*n2*n3*n4  
        y  - points to sample n1*n2*n3*3  
        f2 - output image n1*n2*n3*n4  
         
        Sample a function according to a deformation using trilinear interp.  
        f2 = f1(y)  
        f1, f2 and y are single precision floating point.  
        Uses boundary condiditions that wrap around (circulant - identical to  
        the &#39;samp&#39; option).  
         
       __________________________________________________________________________  
         
        FORMAT f2 = spm_diffeo(&#39;push&#39;, f1, y)  
        f1 - input image(s) n1*n2*n3*n4  
        y  - points to sample n1*n2*n3*3  
        f2 - output image n1*n2*n3*n4  
         
        Push values of a function according to a deformation.  Note that the  
        deformation should be the inverse of the one used with &#39;samp&#39; or  
        &#39;bsplins&#39;. f1, f2 and y are single precision floating point.  
        Voxels in f1 that would be pushed outside the field of view of f2   
        are ignored.  
         
       __________________________________________________________________________  
         
        FORMAT f2 = spm_diffeo(&#39;pushc&#39;, f1, y)  
        f1 - input image(s) n1*n2*n3*n4  
        y  - points to sample n1*n2*n3*3  
        f2 - output image n1*n2*n3*n4  
         
        Push values of a function according to a deformation, but using  
        circulant boundary conditions.  Data wraps around (circulant).  
        f1, f2 and y are single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT ut = spm_diffeo(&#39;pushg&#39;, u0, y)  
        u0 - input momentum n1*n2*n3*3  
        y  - points to sample n1*n2*n3*3  
        ut - output momentum n1*n2*n3*3  
         
        FORMAT ut = spm_diffeo(&#39;pushg&#39;, u0, y)  
        u0 - input momentum n1*n2*n3*3  
        y  - points to sample n1*n2*n3*3  
        J  - Jacobian tensor field of y n1*n2*n3*3*3  
        ut - output momentum n1*n2*n3*3  
         
        Push values of a momentum field according to a deformation using  
        circulant boundary conditions.  This essentially computes  
        (Ad_y)^* u = |det dy| (dy)^T u(y), which is a key to the  
        EPdiff equations used for geodesic shooting.  
        u0, ut and y are single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT f2 = spm_diffeo(&#39;resize&#39;, f1, dim)  
        f1  - input fields n1*n2*n3*n4  
        f2  - output field dim1*dim2*dim3*n4  
        dim - output dimensions  
         
        Resize a field according to dimensions dim.  This is a component of  
        the multigrid approach, and is used for prolongation.  
         
       __________________________________________________________________________  
         
        FORMAT v2 = spm_diffeo(&#39;restrict&#39;, v1)  
        v1  - input fields n1*n2*n3*n4  
        v2  - output field dim1*dim2*dim3*n4  
         
        Restricts a field such that its dimensions are approximately half  
        their original.  This is a component of the multigrid approach.  
         
       __________________________________________________________________________  
         
        FORMAT J = spm_diffeo(&#39;def2jac&#39;,y)  
        y - Deformation field  
        J - Jacobian tensor field of y  
         
        Compute Jacobian tensors from a deformation.  
         
       __________________________________________________________________________  
         
        FORMAT J = spm_diffeo(&#39;def2det&#39;,y)  
        y - Deformation field  
        j - Jacobian determinant field of y  
         
        Compute Jacobian determinants from a deformation.  
         
       __________________________________________________________________________  
         
        FORMAT j = spm_diffeo(&#39;det&#39;,J)  
        J - Jacobian tensor field  
        j - Jacobian determinant field  
         
        Compute determinants of Jacobian tensors.  
         
       __________________________________________________________________________  
         
        FORMAT g = spm_diffeo(&#39;grad&#39;,v)  
        v  - velocity field  
        g  - gradient of velocity field  
         
        The grad option can be applied to any collection of 3D volumes. If  
        the input has dimensions d1 x d2 x d3 x d4 x d5..., then the output  
        has dimensions d1 x d2 x d3 x (d4xd5...) x 3.  
         
       __________________________________________________________________________  
         
        FORMAT dv = spm_diffeo(&#39;div&#39;,v)  
        v  - velocity field  
        dv - divergences of velocity field  
         
        Computes divergence from velocity field.  This is indicative of rates  
        of volumetric expansion/contraction.  
         
       __________________________________________________________________________  
         
        FORMAT [y,J] = spm_diffeo(&#39;smalldef&#39;,v,s)  
        v - velocity field  
        s - scaling factor  
        y - small deformation  
        J - approximate Jacobian tensors of small deformation (computed via  
            a matrix exponsntial of the Jacobians of the velocity field).  
         
        This function is used for each time step of geodesic shooting.  It may  
        change in future to use some form of Pade approximation of the  
        small deformation.  
         
       __________________________________________________________________________  
         
        FORMAT t = spm_diffeo(&#39;trapprox&#39;,H, param)  
        v     - the solution n1*n2*n3*3  
        H     - parameterisation of 2nd derivatives   
        param - 10 parameters (settings)  
                - [1][2][3] Voxel sizes  
                - [4][5][6][7][8] Regularisation settings (see vel2mom).  
        t     - approximation of [trace((L+H)\L) trace((L+H)\H)];  
         
        Generate an approximation of Trace((L+H)\L) and Trace((L+H)\H) for  
        to give a ball-park figure for the &#34;degrees of freedom&#34; in Laplace  
        approximations.  L is the regulariser in sparse matrix form.  The  
        approximation is a poor one, which assumes all the off-diagonals of L  
        are 0.  
        H is single precision floating point.  
         
       __________________________________________________________________________  
         
        FORMAT v = spm_diffeo(&#39;dartel&#39;,v,g,f,param)  
        v     - flow field n1*n2*n3*3 (single precision float)  
        g     - first image n1*n2*n3*n4 (single precision float)  
        f     - second image n1*n2*n3*n4 (single precision float)  
        param - 9 parameters (settings)  
              - [1][2][3][4][5] Regularisation parameters  
              - [1] Absolute displacements need to be penalised by a tiny  
                    amount.  The first element encodes the amount of  
                    penalty on these.  Ideally, absolute displacements  
                    should not be penalised.  
              - [2] The `membrane energy&#39; of the deformation is penalised,  
                    usually by a relatively small amount. This penalises  
                    the sum of squares of the derivatives of the velocity  
                    field (ie the sum of squares of the elements of the  
                    Jacobian tensors).  
              - [3] The `bending energy&#39; is penalised. This penalises the  
                    sum of squares of the 2nd derivatives of the velocity.  
              - [4][5] Linear elasticity regularisation is also included.  
                       The first parameter (mu) is similar to that for  
                       linear elasticity, except it penalises the sum of  
                       squares of the Jacobian tensors after they have been  
                       made symmetric (by averaging with the transpose).  
                       This term essentially penalises length changes,  
                       without penalising rotations.  
                       The final term also relates to linear elasticity,  
                       and is the weight that denotes how much to penalise  
                       changes to the divergence of the velocities (lambda).  
                       This divergence is a measure of the rate of volumetric  
                       expansion or contraction.  
                - [6] Number of Full Multigrid cycles  
                - [7] Number of relaxation iterations per cycle  
                - [8] K, such that 2^K time points are used to  
                      generate the deformations.  A value of zero  
                      indicates a small deformation model.  
                - [9] code of 0, 1 or 2.  
                      0 - asymmetric sums of squares objective function.  
                      1 -  symmetric sums of squares objective function.  
                      2 - assumes multinomial distribution, where template  
                          encodes the means and interpolation of template  
                          done using logs and softmax function.  
         
        This is for performing a single iteration of the Dartel optimisation.  
        All velocity fields and images are represented by single precision floating  
        point values. Images can be scalar fields, in which case the objective  
        function is the sum of squares difference.  Alternatively, images can be  
        vector fields, in which case the objective function is the sum of squares  
        difference between each scalar field + the sum of squares difference  
        between one minus the sum of the scalar fields.  
         
       __________________________________________________________________________  
         
        FORMAT [y,J] = spm_diffeo(&#39;Exp&#39;, v, param)  
        v - flow field  
        J - Jacobian. Usually a tensor field of Jacobian matrices, but can  
            be a field of Jacobian determinants.  
        param - 2 (or 3) parameters.  
                [1] K, the number of recursions (squaring steps), such  
                    that exponentiation is done using an Euler-like  
                    integration with 2^K time steps.  
                [2] a scaling parameter.  
                If there is a third parameter, and it is set to 1, then  
                the J will be the Jacobian determinants.  
         
        A flow field is &#34;exponentiated&#34; to generate a deformation field  
        using a scaling and squaring approach.  See the work of Arsigny  
        et al, or Cleve Moler&#39;s &#34;19 Dubious Ways&#34; papers.  
         
       __________________________________________________________________________  
         
        Note that the boundary conditions are circulant throughout.  
        Interpolation is trilinear, except for the resize function  
        which uses a 2nd degree B-spline (without first deconvolving).  
         
       __________________________________________________________________________  
      

    [Matlab code]( https://github.com/spm/spm/blob/main/spm_diffeo.m )

    Copyright (C) 1995-2025 Functional Imaging Laboratory, Department of Imaging Neuroscience, UCL
    &#34;&#34;&#34;
    return Runtime.call(&#34;spm_diffeo&#34;, *args, **kwargs)</code></pre>
</details>
<div class="desc"><p>MEX function called for image registration stuff
</p>
<hr>
<pre><code>FORMAT u = spm_diffeo('vel2mom', v, param)  
v     - velocity (flow) field n1*n2*n3*3.  
param - 8 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6][7][8] Regularisation parameters  
          - [4] Absolute displacements need to be penalised by a tiny  
                amount.  The first element encodes the amount of  
                penalty on these.  Ideally, absolute displacements  
                should not be penalised, but it is often necessary  
                for technical reasons.  
          - [5] The `membrane energy' of the deformation is penalised,  
                usually by a relatively small amount. This penalises  
                the sum of squares of the derivatives of the velocity  
                field (ie the sum of squares of the elements of the  
                Jacobian tensors).  
          - [6] The `bending energy' is penalised. This penalises the  
                sum of squares of the 2nd derivatives of the parameters.  
          - [7][8] Linear elasticity regularisation is also included.  
                   The first parameter (mu) is similar to that for  
                   linear elasticity, except it penalises the sum of  
                   squares of the Jacobian tensors after they have been  
                   made symmetric (by averaging with the transpose).  
                   This term essentially penalises length changes,  
                   without penalising rotations.  
                   The final term also relates to linear elasticity,  
                   and is the weight that denotes how much to penalise  
                   changes to the divergence of the velocities (lambda).  
                   This divergence is a measure of the rate of volumetric  
                   expansion or contraction.  
u       - `momentum' field n1*n2*n3*3.

Convert a velocity field to a momentum field by u = A*v, where  
A is the large sparse matrix encoding some form of regularisation.  
v and m are single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT v = spm_diffeo('mom2vel',g, param)  
v     - the solution n1*n2*n3*3  
g     - parameterisation of first derivatives  
param - 10 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6][7][8] Regularisation settings (see vel2mom).  
        - [9] Number of Full Multigrid cycles.  
        - [10] Number of relaxation iterations per cycle.

Solve equations using a Full Multigrid method.  See Press et al  
for more information.  
v = inv(A)*g  
g and v are both single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT v = spm_diffeo('fmg',H, g, param)  
v     - the solution n1*n2*n3*3  
H     - parameterisation of 2nd derivatives   
g     - parameterisation of first derivatives  
param - 10 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6][7][8] Regularisation settings (see vel2mom).  
        - [9] Number of Full Multigrid cycles.  
        - [10] Number of relaxation iterations per cycle.

Solve equations using a Full Multigrid method, but using Hessian of  
the matching term.  See Press et al for more information.  
v = inv(A+H)*g  
H, g and v are all single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT v = spm_diffeo('cgs',H, g, param)  
v     - the solution  
H     - parameterisation of 2nd derivatives  
g     - parameterisation of first derivatives  
param - 10 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6][7][8] Regularisation settings (see vel2mom).  
        - [9] Tolerance.  Indicates required degree of accuracy.  
        - [10] Maximum number of iterations.

This is for solving a set of equations using a conjugate gradient  
solver. This method is less efficient than the Full Multigrid, and  
is included for illustrative purposes.  
v = inv(A+H)*g  
H, g and v are all single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT F = spm_diffeo('kernel',d,prm)  
d   - image dimensions  
prm - 8 parameters (settings).  
      These are described above (for 'vel2mom').  
F   - The differential operator encoded as an image (or images).  
      Convolving a velocity field by this will give the momentum.

      Note that a smaller (3D) kernel is obtained when the linear  
      elasticity settings are all zero.  If any of the linear  
      elasticity settings are non-zero, the resulting kernel is  
      represented by a 5D array. For the 3D form, the voxel sizes  
      need to be incorporated as an additional scaling of the kernel.  
      See the code in spm_shoot_greens.m for an illustration.
</code></pre>
<hr>
<pre><code>FORMAT y3 = spm_diffeo('comp',y1,y2)  
y1, y2 - deformation fields n1*n2*n3*3.  
y3     - deformation field field n1*n2*n3*3.

Composition of two deformations y3 = y1(y2)  
y1, y2 and y3 are single precision floating point.


FORMAT [y3,J3] = spm_diffeo('comp', y1, y2, J1, J2)  
y1, y2 - deformation fields n1*n2*n3*3.  
y3     - deformation field n1*n2*n3*3.  
J1, J2 - Jacobian tensor fields n1*n2*n3*3*3.  
J3     - Jacobian tensor field n1*n2*n3*3*3.

Composition of two deformations, with their Jacobian fields.  
All fields are single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT iy = spm_diffeo('invdef',y,d,M1,M2);

iy - inverted deformation field of size d(1)*d(2)*d(3)*3.  
y  - original deformation field.  
M1 - An affine mapping from mm to voxels in the coordinate  
     system of the inverse deformation field.  
M2 - An affine mapping from voxels to mm in the coordinate  
     system of the forward deformation field.

Inversion of a deformation field.

The field is assumed to consist of a piecewise affine transformations,  
whereby each cube jointing 8 neighbouring voxels contains eight  
tetrahedra.  The mapping within each tetrahedron is assumed to be  
affine.

 Reference:  
   J. Ashburner, J. Andersson and K. J. Friston (2000).  
   "Image Registration using a Symmetric Prior - in Three-Dimensions".  
   Human Brain Mapping 9(4):212-225 (appendix).
</code></pre>
<hr>
<pre><code>FORMAT [f,dfx,dfy,dfz] = spm_diffeo('bsplins', c, y,d)  
c          - input image(s) of B-spline coefficients n1*n2*n3*n4  
             - see 'bsplinc'  
y          - points to sample n1*n2*n3*3  
d(1:3)     - degree of B-spline (from 0 to 7) along different dimensions  
             - these must be same as used by 'bsplinc'  
d(4:6)     - 1/0 to indicate wrapping along the dimensions

f           - output image n1*n2*n3*n4  
dfx,dfy,dfz - sampled first derivatives

c, f and y are single precision floating point.

This function takes B-spline basis coefficients from spm_bsplinc,  
and re-convolves them with B-splines centred at the new sample points.

Note that nearest neighbour interpolation is used instead of 0th  
degree B-splines, and the derivatives of trilinear interpolation are  
returned instead of those of 1st degree B-splines.  The difference is  
extremely subtle.

c, f and y are single precision floating point.

 References:  
   M. Unser, A. Aldroubi and M. Eden.  
   "B-Spline Signal Processing: Part I-Theory,"  
   IEEE Transactions on Signal Processing 41(2):821-832 (1993).

   M. Unser, A. Aldroubi and M. Eden.  
   "B-Spline Signal Processing: Part II-Efficient Design and  
   Applications,"  
   IEEE Transactions on Signal Processing 41(2):834-848 (1993).

   M. Unser.  
   "Splines: A Perfect Fit for Signal and Image Processing,"  
   IEEE Signal Processing Magazine, 16(6):22-38 (1999)

   P. Thevenaz and T. Blu and M. Unser.  
   "Interpolation Revisited"  
   IEEE Transactions on Medical Imaging 19(7):739-758 (2000).
</code></pre>
<hr>
<pre><code>FORMAT c = spm_diffeo('bsplinc',f,d)  
  f - an image  
  d(1:3) - degree of B-spline (from 0 to 7) along different dimensions  
      d(4:6) - 1/0 to indicate wrapping along the dimensions  
  c - returned volume of B-spline coefficients

This function deconvolves B-splines from f, returning  
coefficients, c.  These coefficients are then passed to 'bsplins'  
in order to sample the data using B-spline interpolation.
</code></pre>
<hr>
<pre><code>FORMAT f2 = spm_diffeo('samp', f1, y)  
f1 - input image(s) n1*n2*n3*n4  
y  - points to sample n1*n2*n3*3  
f2 - output image n1*n2*n3*n4

Sample a function according to a deformation using trilinear interp.  
f2 = f1(y)  
f1, f2 and y are single precision floating point.  
Uses boundary condiditions that wrap around (circulant - identical to  
the 'pullc' option - but retained for backward compatibility).
</code></pre>
<hr>
<pre><code>FORMAT f2 = spm_diffeo('pull', f1, y)  
f1 - input image(s) n1*n2*n3*n4  
y  - points to sample n1*n2*n3*3  
f2 - output image n1*n2*n3*n4

Sample a function according to a deformation using trilinear interp.  
f2 = f1(y)  
f1, f2 and y are single precision floating point.  
Values sampled outside the field of view of f1 are assigned a value  
of NaN.
</code></pre>
<hr>
<pre><code>FORMAT f2 = spm_diffeo('pullc', f1, y)  
f1 - input image(s) n1*n2*n3*n4  
y  - points to sample n1*n2*n3*3  
f2 - output image n1*n2*n3*n4

Sample a function according to a deformation using trilinear interp.  
f2 = f1(y)  
f1, f2 and y are single precision floating point.  
Uses boundary condiditions that wrap around (circulant - identical to  
the 'samp' option).
</code></pre>
<hr>
<pre><code>FORMAT f2 = spm_diffeo('push', f1, y)  
f1 - input image(s) n1*n2*n3*n4  
y  - points to sample n1*n2*n3*3  
f2 - output image n1*n2*n3*n4

Push values of a function according to a deformation.  Note that the  
deformation should be the inverse of the one used with 'samp' or  
'bsplins'. f1, f2 and y are single precision floating point.  
Voxels in f1 that would be pushed outside the field of view of f2   
are ignored.
</code></pre>
<hr>
<pre><code>FORMAT f2 = spm_diffeo('pushc', f1, y)  
f1 - input image(s) n1*n2*n3*n4  
y  - points to sample n1*n2*n3*3  
f2 - output image n1*n2*n3*n4

Push values of a function according to a deformation, but using  
circulant boundary conditions.  Data wraps around (circulant).  
f1, f2 and y are single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT ut = spm_diffeo('pushg', u0, y)  
u0 - input momentum n1*n2*n3*3  
y  - points to sample n1*n2*n3*3  
ut - output momentum n1*n2*n3*3

FORMAT ut = spm_diffeo('pushg', u0, y)  
u0 - input momentum n1*n2*n3*3  
y  - points to sample n1*n2*n3*3  
J  - Jacobian tensor field of y n1*n2*n3*3*3  
ut - output momentum n1*n2*n3*3

Push values of a momentum field according to a deformation using  
circulant boundary conditions.  This essentially computes  
(Ad_y)^* u = |det dy| (dy)^T u(y), which is a key to the  
EPdiff equations used for geodesic shooting.  
u0, ut and y are single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT f2 = spm_diffeo('resize', f1, dim)  
f1  - input fields n1*n2*n3*n4  
f2  - output field dim1*dim2*dim3*n4  
dim - output dimensions

Resize a field according to dimensions dim.  This is a component of  
the multigrid approach, and is used for prolongation.
</code></pre>
<hr>
<pre><code>FORMAT v2 = spm_diffeo('restrict', v1)  
v1  - input fields n1*n2*n3*n4  
v2  - output field dim1*dim2*dim3*n4

Restricts a field such that its dimensions are approximately half  
their original.  This is a component of the multigrid approach.
</code></pre>
<hr>
<pre><code>FORMAT J = spm_diffeo('def2jac',y)  
y - Deformation field  
J - Jacobian tensor field of y

Compute Jacobian tensors from a deformation.
</code></pre>
<hr>
<pre><code>FORMAT J = spm_diffeo('def2det',y)  
y - Deformation field  
j - Jacobian determinant field of y

Compute Jacobian determinants from a deformation.
</code></pre>
<hr>
<pre><code>FORMAT j = spm_diffeo('det',J)  
J - Jacobian tensor field  
j - Jacobian determinant field

Compute determinants of Jacobian tensors.
</code></pre>
<hr>
<pre><code>FORMAT g = spm_diffeo('grad',v)  
v  - velocity field  
g  - gradient of velocity field

The grad option can be applied to any collection of 3D volumes. If  
the input has dimensions d1 x d2 x d3 x d4 x d5..., then the output  
has dimensions d1 x d2 x d3 x (d4xd5...) x 3.
</code></pre>
<hr>
<pre><code>FORMAT dv = spm_diffeo('div',v)  
v  - velocity field  
dv - divergences of velocity field

Computes divergence from velocity field.  This is indicative of rates  
of volumetric expansion/contraction.
</code></pre>
<hr>
<pre><code>FORMAT [y,J] = spm_diffeo('smalldef',v,s)  
v - velocity field  
s - scaling factor  
y - small deformation  
J - approximate Jacobian tensors of small deformation (computed via  
    a matrix exponsntial of the Jacobians of the velocity field).

This function is used for each time step of geodesic shooting.  It may  
change in future to use some form of Pade approximation of the  
small deformation.
</code></pre>
<hr>
<pre><code>FORMAT t = spm_diffeo('trapprox',H, param)  
v     - the solution n1*n2*n3*3  
H     - parameterisation of 2nd derivatives   
param - 10 parameters (settings)  
        - [1][2][3] Voxel sizes  
        - [4][5][6][7][8] Regularisation settings (see vel2mom).  
t     - approximation of [trace((L+H)\L) trace((L+H)\H)];

Generate an approximation of Trace((L+H)\L) and Trace((L+H)\H) for  
to give a ball-park figure for the "degrees of freedom" in Laplace  
approximations.  L is the regulariser in sparse matrix form.  The  
approximation is a poor one, which assumes all the off-diagonals of L  
are 0.  
H is single precision floating point.
</code></pre>
<hr>
<pre><code>FORMAT v = spm_diffeo('dartel',v,g,f,param)  
v     - flow field n1*n2*n3*3 (single precision float)  
g     - first image n1*n2*n3*n4 (single precision float)  
f     - second image n1*n2*n3*n4 (single precision float)  
param - 9 parameters (settings)  
      - [1][2][3][4][5] Regularisation parameters  
      - [1] Absolute displacements need to be penalised by a tiny  
            amount.  The first element encodes the amount of  
            penalty on these.  Ideally, absolute displacements  
            should not be penalised.  
      - [2] The `membrane energy' of the deformation is penalised,  
            usually by a relatively small amount. This penalises  
            the sum of squares of the derivatives of the velocity  
            field (ie the sum of squares of the elements of the  
            Jacobian tensors).  
      - [3] The `bending energy' is penalised. This penalises the  
            sum of squares of the 2nd derivatives of the velocity.  
      - [4][5] Linear elasticity regularisation is also included.  
               The first parameter (mu) is similar to that for  
               linear elasticity, except it penalises the sum of  
               squares of the Jacobian tensors after they have been  
               made symmetric (by averaging with the transpose).  
               This term essentially penalises length changes,  
               without penalising rotations.  
               The final term also relates to linear elasticity,  
               and is the weight that denotes how much to penalise  
               changes to the divergence of the velocities (lambda).  
               This divergence is a measure of the rate of volumetric  
               expansion or contraction.  
        - [6] Number of Full Multigrid cycles  
        - [7] Number of relaxation iterations per cycle  
        - [8] K, such that 2^K time points are used to  
              generate the deformations.  A value of zero  
              indicates a small deformation model.  
        - [9] code of 0, 1 or 2.  
              0 - asymmetric sums of squares objective function.  
              1 -  symmetric sums of squares objective function.  
              2 - assumes multinomial distribution, where template  
                  encodes the means and interpolation of template  
                  done using logs and softmax function.

This is for performing a single iteration of the Dartel optimisation.  
All velocity fields and images are represented by single precision floating  
point values. Images can be scalar fields, in which case the objective  
function is the sum of squares difference.  Alternatively, images can be  
vector fields, in which case the objective function is the sum of squares  
difference between each scalar field + the sum of squares difference  
between one minus the sum of the scalar fields.
</code></pre>
<hr>
<pre><code>FORMAT [y,J] = spm_diffeo('Exp', v, param)  
v - flow field  
J - Jacobian. Usually a tensor field of Jacobian matrices, but can  
    be a field of Jacobian determinants.  
param - 2 (or 3) parameters.  
        [1] K, the number of recursions (squaring steps), such  
            that exponentiation is done using an Euler-like  
            integration with 2^K time steps.  
        [2] a scaling parameter.  
        If there is a third parameter, and it is set to 1, then  
        the J will be the Jacobian determinants.

A flow field is "exponentiated" to generate a deformation field  
using a scaling and squaring approach.  See the work of Arsigny  
et al, or Cleve Moler's "19 Dubious Ways" papers.
</code></pre>
<hr>
<pre><code>Note that the boundary conditions are circulant throughout.  
Interpolation is trilinear, except for the resize function  
which uses a 2nd degree B-spline (without first deconvolving).
</code></pre>
<hr>
<p><a href="https://github.com/spm/spm/blob/main/spm_diffeo.m">Matlab code</a></p>
<p>Copyright (C) 1995-2025 Functional Imaging Laboratory, Department of Imaging Neuroscience, UCL</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spm" href="index.html">spm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spm.spm_diffeo.spm_diffeo" href="#spm.spm_diffeo.spm_diffeo">spm_diffeo</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
